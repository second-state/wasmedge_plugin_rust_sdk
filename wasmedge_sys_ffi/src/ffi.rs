/* automatically generated by rust-bindgen 0.64.0 */

// bindgen --impl-debug --size_t-is-usize --no-layout-tests  /home/csh/workspace/WasmEdge-13/build/include/api/wasmedge/wasmedge.h --no-prepend-enum-name --dynamic-link-require-all --allowlist-type="WasmEdge.*" --allowlist-var="WasmEdge.*" --allowlist-function="WasmEdge.*" -o ffi.rs -- -I/home/csh/workspace/WasmEdge-13/build/include/api/
// wasmedge 0.13.0
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(improper_ctypes)]

pub const WasmEdge_Plugin_CurrentAPIVersion: u32 = 2;
pub const WasmEdge_Proposal_ImportExportMutGlobals: WasmEdge_Proposal = 0;
pub const WasmEdge_Proposal_NonTrapFloatToIntConversions: WasmEdge_Proposal = 1;
pub const WasmEdge_Proposal_SignExtensionOperators: WasmEdge_Proposal = 2;
pub const WasmEdge_Proposal_MultiValue: WasmEdge_Proposal = 3;
pub const WasmEdge_Proposal_BulkMemoryOperations: WasmEdge_Proposal = 4;
pub const WasmEdge_Proposal_ReferenceTypes: WasmEdge_Proposal = 5;
pub const WasmEdge_Proposal_SIMD: WasmEdge_Proposal = 6;
pub const WasmEdge_Proposal_TailCall: WasmEdge_Proposal = 7;
pub const WasmEdge_Proposal_MultiMemories: WasmEdge_Proposal = 8;
pub const WasmEdge_Proposal_Annotations: WasmEdge_Proposal = 9;
pub const WasmEdge_Proposal_Memory64: WasmEdge_Proposal = 10;
pub const WasmEdge_Proposal_ExceptionHandling: WasmEdge_Proposal = 11;
pub const WasmEdge_Proposal_ExtendedConst: WasmEdge_Proposal = 12;
pub const WasmEdge_Proposal_Threads: WasmEdge_Proposal = 13;
pub const WasmEdge_Proposal_FunctionReferences: WasmEdge_Proposal = 14;
#[doc = " WASM Proposal C enumeration."]
pub type WasmEdge_Proposal = ::std::os::raw::c_uint;
pub const WasmEdge_HostRegistration_Wasi: WasmEdge_HostRegistration = 0;
#[doc = " Host Module Registration C enumeration."]
pub type WasmEdge_HostRegistration = ::std::os::raw::c_uint;
pub const WasmEdge_CompilerOptimizationLevel_O0: WasmEdge_CompilerOptimizationLevel = 0;
pub const WasmEdge_CompilerOptimizationLevel_O1: WasmEdge_CompilerOptimizationLevel = 1;
pub const WasmEdge_CompilerOptimizationLevel_O2: WasmEdge_CompilerOptimizationLevel = 2;
pub const WasmEdge_CompilerOptimizationLevel_O3: WasmEdge_CompilerOptimizationLevel = 3;
pub const WasmEdge_CompilerOptimizationLevel_Os: WasmEdge_CompilerOptimizationLevel = 4;
pub const WasmEdge_CompilerOptimizationLevel_Oz: WasmEdge_CompilerOptimizationLevel = 5;
#[doc = " AOT compiler optimization level C enumeration."]
pub type WasmEdge_CompilerOptimizationLevel = ::std::os::raw::c_uint;
pub const WasmEdge_CompilerOutputFormat_Native: WasmEdge_CompilerOutputFormat = 0;
pub const WasmEdge_CompilerOutputFormat_Wasm: WasmEdge_CompilerOutputFormat = 1;
#[doc = " AOT compiler output binary format C enumeration."]
pub type WasmEdge_CompilerOutputFormat = ::std::os::raw::c_uint;
pub const WasmEdge_ErrCategory_WASM: WasmEdge_ErrCategory = 0;
pub const WasmEdge_ErrCategory_UserLevelError: WasmEdge_ErrCategory = 1;
#[doc = " Error category C enumeration."]
pub type WasmEdge_ErrCategory = ::std::os::raw::c_uint;
pub const WasmEdge_ErrCode_Success: WasmEdge_ErrCode = 0;
pub const WasmEdge_ErrCode_Terminated: WasmEdge_ErrCode = 1;
pub const WasmEdge_ErrCode_RuntimeError: WasmEdge_ErrCode = 2;
pub const WasmEdge_ErrCode_CostLimitExceeded: WasmEdge_ErrCode = 3;
pub const WasmEdge_ErrCode_WrongVMWorkflow: WasmEdge_ErrCode = 4;
pub const WasmEdge_ErrCode_FuncNotFound: WasmEdge_ErrCode = 5;
pub const WasmEdge_ErrCode_AOTDisabled: WasmEdge_ErrCode = 6;
pub const WasmEdge_ErrCode_Interrupted: WasmEdge_ErrCode = 7;
pub const WasmEdge_ErrCode_NotValidated: WasmEdge_ErrCode = 8;
pub const WasmEdge_ErrCode_UserDefError: WasmEdge_ErrCode = 9;
pub const WasmEdge_ErrCode_IllegalPath: WasmEdge_ErrCode = 32;
pub const WasmEdge_ErrCode_ReadError: WasmEdge_ErrCode = 33;
pub const WasmEdge_ErrCode_UnexpectedEnd: WasmEdge_ErrCode = 34;
pub const WasmEdge_ErrCode_MalformedMagic: WasmEdge_ErrCode = 35;
pub const WasmEdge_ErrCode_MalformedVersion: WasmEdge_ErrCode = 36;
pub const WasmEdge_ErrCode_MalformedSection: WasmEdge_ErrCode = 37;
pub const WasmEdge_ErrCode_SectionSizeMismatch: WasmEdge_ErrCode = 38;
pub const WasmEdge_ErrCode_LengthOutOfBounds: WasmEdge_ErrCode = 39;
pub const WasmEdge_ErrCode_JunkSection: WasmEdge_ErrCode = 40;
pub const WasmEdge_ErrCode_IncompatibleFuncCode: WasmEdge_ErrCode = 41;
pub const WasmEdge_ErrCode_IncompatibleDataCount: WasmEdge_ErrCode = 42;
pub const WasmEdge_ErrCode_DataCountRequired: WasmEdge_ErrCode = 43;
pub const WasmEdge_ErrCode_MalformedImportKind: WasmEdge_ErrCode = 44;
pub const WasmEdge_ErrCode_MalformedExportKind: WasmEdge_ErrCode = 45;
pub const WasmEdge_ErrCode_ExpectedZeroByte: WasmEdge_ErrCode = 46;
pub const WasmEdge_ErrCode_InvalidMut: WasmEdge_ErrCode = 47;
pub const WasmEdge_ErrCode_TooManyLocals: WasmEdge_ErrCode = 48;
pub const WasmEdge_ErrCode_MalformedValType: WasmEdge_ErrCode = 49;
pub const WasmEdge_ErrCode_MalformedElemType: WasmEdge_ErrCode = 50;
pub const WasmEdge_ErrCode_MalformedRefType: WasmEdge_ErrCode = 51;
pub const WasmEdge_ErrCode_MalformedUTF8: WasmEdge_ErrCode = 52;
pub const WasmEdge_ErrCode_IntegerTooLarge: WasmEdge_ErrCode = 53;
pub const WasmEdge_ErrCode_IntegerTooLong: WasmEdge_ErrCode = 54;
pub const WasmEdge_ErrCode_IllegalOpCode: WasmEdge_ErrCode = 55;
pub const WasmEdge_ErrCode_ENDCodeExpected: WasmEdge_ErrCode = 56;
pub const WasmEdge_ErrCode_IllegalGrammar: WasmEdge_ErrCode = 57;
pub const WasmEdge_ErrCode_SharedMemoryNoMax: WasmEdge_ErrCode = 58;
pub const WasmEdge_ErrCode_IntrinsicsTableNotFound: WasmEdge_ErrCode = 59;
pub const WasmEdge_ErrCode_InvalidAlignment: WasmEdge_ErrCode = 64;
pub const WasmEdge_ErrCode_TypeCheckFailed: WasmEdge_ErrCode = 65;
pub const WasmEdge_ErrCode_InvalidLabelIdx: WasmEdge_ErrCode = 66;
pub const WasmEdge_ErrCode_InvalidLocalIdx: WasmEdge_ErrCode = 67;
pub const WasmEdge_ErrCode_InvalidFuncTypeIdx: WasmEdge_ErrCode = 68;
pub const WasmEdge_ErrCode_InvalidFuncIdx: WasmEdge_ErrCode = 69;
pub const WasmEdge_ErrCode_InvalidTableIdx: WasmEdge_ErrCode = 70;
pub const WasmEdge_ErrCode_InvalidMemoryIdx: WasmEdge_ErrCode = 71;
pub const WasmEdge_ErrCode_InvalidGlobalIdx: WasmEdge_ErrCode = 72;
pub const WasmEdge_ErrCode_InvalidElemIdx: WasmEdge_ErrCode = 73;
pub const WasmEdge_ErrCode_InvalidDataIdx: WasmEdge_ErrCode = 74;
pub const WasmEdge_ErrCode_InvalidRefIdx: WasmEdge_ErrCode = 75;
pub const WasmEdge_ErrCode_ConstExprRequired: WasmEdge_ErrCode = 76;
pub const WasmEdge_ErrCode_DupExportName: WasmEdge_ErrCode = 77;
pub const WasmEdge_ErrCode_ImmutableGlobal: WasmEdge_ErrCode = 78;
pub const WasmEdge_ErrCode_InvalidResultArity: WasmEdge_ErrCode = 79;
pub const WasmEdge_ErrCode_MultiTables: WasmEdge_ErrCode = 80;
pub const WasmEdge_ErrCode_MultiMemories: WasmEdge_ErrCode = 81;
pub const WasmEdge_ErrCode_InvalidLimit: WasmEdge_ErrCode = 82;
pub const WasmEdge_ErrCode_InvalidMemPages: WasmEdge_ErrCode = 83;
pub const WasmEdge_ErrCode_InvalidStartFunc: WasmEdge_ErrCode = 84;
pub const WasmEdge_ErrCode_InvalidLaneIdx: WasmEdge_ErrCode = 85;
pub const WasmEdge_ErrCode_ModuleNameConflict: WasmEdge_ErrCode = 96;
pub const WasmEdge_ErrCode_IncompatibleImportType: WasmEdge_ErrCode = 97;
pub const WasmEdge_ErrCode_UnknownImport: WasmEdge_ErrCode = 98;
pub const WasmEdge_ErrCode_DataSegDoesNotFit: WasmEdge_ErrCode = 99;
pub const WasmEdge_ErrCode_ElemSegDoesNotFit: WasmEdge_ErrCode = 100;
pub const WasmEdge_ErrCode_WrongInstanceAddress: WasmEdge_ErrCode = 128;
pub const WasmEdge_ErrCode_WrongInstanceIndex: WasmEdge_ErrCode = 129;
pub const WasmEdge_ErrCode_InstrTypeMismatch: WasmEdge_ErrCode = 130;
pub const WasmEdge_ErrCode_FuncSigMismatch: WasmEdge_ErrCode = 131;
pub const WasmEdge_ErrCode_DivideByZero: WasmEdge_ErrCode = 132;
pub const WasmEdge_ErrCode_IntegerOverflow: WasmEdge_ErrCode = 133;
pub const WasmEdge_ErrCode_InvalidConvToInt: WasmEdge_ErrCode = 134;
pub const WasmEdge_ErrCode_TableOutOfBounds: WasmEdge_ErrCode = 135;
pub const WasmEdge_ErrCode_MemoryOutOfBounds: WasmEdge_ErrCode = 136;
pub const WasmEdge_ErrCode_Unreachable: WasmEdge_ErrCode = 137;
pub const WasmEdge_ErrCode_UninitializedElement: WasmEdge_ErrCode = 138;
pub const WasmEdge_ErrCode_UndefinedElement: WasmEdge_ErrCode = 139;
pub const WasmEdge_ErrCode_IndirectCallTypeMismatch: WasmEdge_ErrCode = 140;
pub const WasmEdge_ErrCode_HostFuncError: WasmEdge_ErrCode = 141;
pub const WasmEdge_ErrCode_RefTypeMismatch: WasmEdge_ErrCode = 142;
pub const WasmEdge_ErrCode_UnalignedAtomicAccess: WasmEdge_ErrCode = 143;
pub const WasmEdge_ErrCode_ExpectSharedMemory: WasmEdge_ErrCode = 144;
#[doc = " Error code C enumeration."]
pub type WasmEdge_ErrCode = ::std::os::raw::c_uint;
pub const WasmEdge_ValType_I32: WasmEdge_ValType = 127;
pub const WasmEdge_ValType_I64: WasmEdge_ValType = 126;
pub const WasmEdge_ValType_F32: WasmEdge_ValType = 125;
pub const WasmEdge_ValType_F64: WasmEdge_ValType = 124;
pub const WasmEdge_ValType_V128: WasmEdge_ValType = 123;
pub const WasmEdge_ValType_FuncRef: WasmEdge_ValType = 112;
pub const WasmEdge_ValType_ExternRef: WasmEdge_ValType = 111;
#[doc = " WASM Value type C enumeration."]
pub type WasmEdge_ValType = ::std::os::raw::c_uint;
pub const WasmEdge_NumType_I32: WasmEdge_NumType = 127;
pub const WasmEdge_NumType_I64: WasmEdge_NumType = 126;
pub const WasmEdge_NumType_F32: WasmEdge_NumType = 125;
pub const WasmEdge_NumType_F64: WasmEdge_NumType = 124;
pub const WasmEdge_NumType_V128: WasmEdge_NumType = 123;
#[doc = " WASM Number type C enumeration."]
pub type WasmEdge_NumType = ::std::os::raw::c_uint;
pub const WasmEdge_RefType_FuncRef: WasmEdge_RefType = 112;
pub const WasmEdge_RefType_ExternRef: WasmEdge_RefType = 111;
#[doc = " WASM Reference type C enumeration."]
pub type WasmEdge_RefType = ::std::os::raw::c_uint;
pub const WasmEdge_Mutability_Const: WasmEdge_Mutability = 0;
pub const WasmEdge_Mutability_Var: WasmEdge_Mutability = 1;
#[doc = " WASM Mutability C enumeration."]
pub type WasmEdge_Mutability = ::std::os::raw::c_uint;
pub const WasmEdge_ExternalType_Function: WasmEdge_ExternalType = 0;
pub const WasmEdge_ExternalType_Table: WasmEdge_ExternalType = 1;
pub const WasmEdge_ExternalType_Memory: WasmEdge_ExternalType = 2;
pub const WasmEdge_ExternalType_Global: WasmEdge_ExternalType = 3;
#[doc = " WASM External type C enumeration."]
pub type WasmEdge_ExternalType = ::std::os::raw::c_uint;
pub type uint128_t = u128;
pub type int128_t = i128;
#[doc = " WasmEdge WASM value struct."]
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_Value {
    pub Value: uint128_t,
    pub Type: WasmEdge_ValType,
}
#[doc = " WasmEdge string struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_String {
    pub Length: u32,
    pub Buf: *const ::std::os::raw::c_char,
}
#[doc = " WasmEdge result struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_Result {
    pub Code: u32,
}
#[doc = " Struct of WASM limit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_Limit {
    #[doc = " Boolean to describe has max value or not."]
    pub HasMax: bool,
    #[doc = " Boolean to describe is shared memory or not."]
    pub Shared: bool,
    #[doc = " Minimum value."]
    pub Min: u32,
    #[doc = " Maximum value. Will be ignored if the `HasMax` is false."]
    pub Max: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_ConfigureContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_StatisticsContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_ASTModuleContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_FunctionTypeContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_MemoryTypeContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_TableTypeContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_GlobalTypeContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_ImportTypeContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_ExportTypeContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_CompilerContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_LoaderContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_ValidatorContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_ExecutorContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_StoreContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_ModuleInstanceContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_FunctionInstanceContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_TableInstanceContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_MemoryInstanceContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_GlobalInstanceContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_CallingFrameContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_Async {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_VMContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_PluginContext {
    _unused: [u8; 0],
}
#[doc = " No option value."]
pub const WasmEdge_ProgramOptionType_None: WasmEdge_ProgramOptionType = 0;
#[doc = " Boolean value."]
pub const WasmEdge_ProgramOptionType_Toggle: WasmEdge_ProgramOptionType = 1;
#[doc = " Boolean value."]
pub const WasmEdge_ProgramOptionType_Int8: WasmEdge_ProgramOptionType = 2;
#[doc = " Boolean value."]
pub const WasmEdge_ProgramOptionType_Int16: WasmEdge_ProgramOptionType = 3;
#[doc = " Boolean value."]
pub const WasmEdge_ProgramOptionType_Int32: WasmEdge_ProgramOptionType = 4;
#[doc = " Boolean value."]
pub const WasmEdge_ProgramOptionType_Int64: WasmEdge_ProgramOptionType = 5;
#[doc = " Boolean value."]
pub const WasmEdge_ProgramOptionType_UInt8: WasmEdge_ProgramOptionType = 6;
#[doc = " Boolean value."]
pub const WasmEdge_ProgramOptionType_UInt16: WasmEdge_ProgramOptionType = 7;
#[doc = " Boolean value."]
pub const WasmEdge_ProgramOptionType_UInt32: WasmEdge_ProgramOptionType = 8;
#[doc = " Boolean value."]
pub const WasmEdge_ProgramOptionType_UInt64: WasmEdge_ProgramOptionType = 9;
#[doc = " Boolean value."]
pub const WasmEdge_ProgramOptionType_Float: WasmEdge_ProgramOptionType = 10;
#[doc = " Boolean value."]
pub const WasmEdge_ProgramOptionType_Double: WasmEdge_ProgramOptionType = 11;
#[doc = " WasmEdge_String."]
pub const WasmEdge_ProgramOptionType_String: WasmEdge_ProgramOptionType = 12;
#[doc = " Type of option value."]
pub type WasmEdge_ProgramOptionType = ::std::os::raw::c_uint;
#[doc = " Program option for plugins."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_ProgramOption {
    pub Name: *const ::std::os::raw::c_char,
    pub Description: *const ::std::os::raw::c_char,
    pub Type: WasmEdge_ProgramOptionType,
    pub Storage: *mut ::std::os::raw::c_void,
    pub DefaultValue: *const ::std::os::raw::c_void,
}
#[doc = " Module descriptor for plugins."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_ModuleDescriptor {
    pub Name: *const ::std::os::raw::c_char,
    pub Description: *const ::std::os::raw::c_char,
    pub Create: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const WasmEdge_ModuleDescriptor,
        ) -> *mut WasmEdge_ModuleInstanceContext,
    >,
}
#[doc = " Version data for plugins."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_PluginVersionData {
    pub Major: u32,
    pub Minor: u32,
    pub Patch: u32,
    pub Build: u32,
}
#[doc = " Plugin descriptor for plugins."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_PluginDescriptor {
    pub Name: *const ::std::os::raw::c_char,
    pub Description: *const ::std::os::raw::c_char,
    pub APIVersion: u32,
    pub Version: WasmEdge_PluginVersionData,
    pub ModuleCount: u32,
    pub ProgramOptionCount: u32,
    pub ModuleDescriptions: *mut WasmEdge_ModuleDescriptor,
    pub ProgramOptions: *mut WasmEdge_ProgramOption,
}
extern "C" {
    #[doc = " Get the version string of the WasmEdge C API.\n\n The returned string must __NOT__ be destroyed.\n\n \\returns NULL-terminated C string of version."]
    pub fn WasmEdge_VersionGet() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the major version value of the WasmEdge C API.\n\n \\returns Value of the major version."]
    pub fn WasmEdge_VersionGetMajor() -> u32;
}
extern "C" {
    #[doc = " Get the minor version value of the WasmEdge C API.\n\n \\returns Value of the minor version."]
    pub fn WasmEdge_VersionGetMinor() -> u32;
}
extern "C" {
    #[doc = " Get the patch version value of the WasmEdge C API.\n\n \\returns Value of the patch version."]
    pub fn WasmEdge_VersionGetPatch() -> u32;
}
extern "C" {
    #[doc = " Set the logging system to filter to error level."]
    pub fn WasmEdge_LogSetErrorLevel();
}
extern "C" {
    #[doc = " Set the logging system to filter to debug level."]
    pub fn WasmEdge_LogSetDebugLevel();
}
extern "C" {
    #[doc = " Set the logging system off."]
    pub fn WasmEdge_LogOff();
}
extern "C" {
    #[doc = " Generate the I32 WASM value.\n\n \\param Val the I32 value.\n\n \\returns WasmEdge_Value struct with the I32 value."]
    pub fn WasmEdge_ValueGenI32(Val: i32) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Generate the I64 WASM value.\n\n \\param Val the I64 value.\n\n \\returns WasmEdge_Value struct with the I64 value."]
    pub fn WasmEdge_ValueGenI64(Val: i64) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Generate the F32 WASM value.\n\n \\param Val the F32 value.\n\n \\returns WasmEdge_Value struct with the F32 value."]
    pub fn WasmEdge_ValueGenF32(Val: f32) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Generate the F64 WASM value.\n\n \\param Val the F64 value.\n\n \\returns WasmEdge_Value struct with the F64 value."]
    pub fn WasmEdge_ValueGenF64(Val: f64) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Generate the V128 WASM value.\n\n \\param Val the V128 value.\n\n \\returns WasmEdge_Value struct with the V128 value."]
    pub fn WasmEdge_ValueGenV128(Val: int128_t) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Generate the NULL reference WASM value.\n\n The values generated by this function are only meaningful when the\n `WasmEdge_Proposal_BulkMemoryOperations` or the\n `WasmEdge_Proposal_ReferenceTypes` turns on in configuration.\n\n \\param T the reference type.\n\n \\returns WasmEdge_Value struct with the NULL reference."]
    pub fn WasmEdge_ValueGenNullRef(T: WasmEdge_RefType) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Generate the function reference WASM value.\n\n The values generated by this function are only meaningful when the\n `WasmEdge_Proposal_BulkMemoryOperations` or the\n `WasmEdge_Proposal_ReferenceTypes` turns on in configuration.\n\n \\param Cxt the function instance context to convert to the reference.\n\n \\returns WasmEdge_Value struct with the function reference."]
    pub fn WasmEdge_ValueGenFuncRef(Cxt: *const WasmEdge_FunctionInstanceContext)
        -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Generate the function reference WASM value.\n\n The values generated by this function are only meaningful when the\n `WasmEdge_Proposal_ReferenceTypes` turns on in configuration.\n\n \\param Ref the reference to the external object.\n\n \\returns WasmEdge_Value struct with the external reference."]
    pub fn WasmEdge_ValueGenExternRef(Ref: *mut ::std::os::raw::c_void) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Retrieve the I32 value from the WASM value.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns I32 value in the input struct."]
    pub fn WasmEdge_ValueGetI32(Val: WasmEdge_Value) -> i32;
}
extern "C" {
    #[doc = " Retrieve the I64 value from the WASM value.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns I64 value in the input struct."]
    pub fn WasmEdge_ValueGetI64(Val: WasmEdge_Value) -> i64;
}
extern "C" {
    #[doc = " Retrieve the F32 value from the WASM value.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns F32 value in the input struct."]
    pub fn WasmEdge_ValueGetF32(Val: WasmEdge_Value) -> f32;
}
extern "C" {
    #[doc = " Retrieve the F64 value from the WASM value.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns F64 value in the input struct."]
    pub fn WasmEdge_ValueGetF64(Val: WasmEdge_Value) -> f64;
}
extern "C" {
    #[doc = " Retrieve the V128 value from the WASM value.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns V128 value in the input struct."]
    pub fn WasmEdge_ValueGetV128(Val: WasmEdge_Value) -> int128_t;
}
extern "C" {
    #[doc = " Specify the WASM value is a null reference or not.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns true if the value is a null reference, false if not."]
    pub fn WasmEdge_ValueIsNullRef(Val: WasmEdge_Value) -> bool;
}
extern "C" {
    #[doc = " Retrieve the function instance context from the WASM value.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns pointer to function instance context in the input struct."]
    pub fn WasmEdge_ValueGetFuncRef(Val: WasmEdge_Value)
        -> *const WasmEdge_FunctionInstanceContext;
}
extern "C" {
    #[doc = " Retrieve the external reference from the WASM value.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns external reference in the input struct."]
    pub fn WasmEdge_ValueGetExternRef(Val: WasmEdge_Value) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Creation of the WasmEdge_String with the C string.\n\n The caller owns the object and should call `WasmEdge_StringDelete` to\n destroy it. This function only supports the C string with NULL termination.\n If the input string may have `\\0` character, please use the\n `WasmEdge_StringCreateByBuffer` instead.\n\n \\param Str the NULL-terminated C string to copy into the WasmEdge_String\n object.\n\n \\returns string object. Length will be 0 and Buf will be NULL if failed or\n the input string is a NULL."]
    pub fn WasmEdge_StringCreateByCString(Str: *const ::std::os::raw::c_char) -> WasmEdge_String;
}
extern "C" {
    #[doc = " Creation of the WasmEdge_String with the buffer and its length.\n\n The caller owns the object and should call `WasmEdge_StringDelete` to\n destroy it.\n\n \\param Buf the buffer to copy into the WasmEdge_String object.\n \\param Len the buffer length.\n\n \\returns string object. Length will be 0 and Buf will be NULL if failed or\n the input buffer is a NULL."]
    pub fn WasmEdge_StringCreateByBuffer(
        Buf: *const ::std::os::raw::c_char,
        Len: u32,
    ) -> WasmEdge_String;
}
extern "C" {
    #[doc = " Create the WasmEdge_String wraps to the buffer.\n\n This function creates a `WasmEdge_String` object which wraps to the input\n buffer. The caller should guarantee the life cycle of the input buffer, and\n should __NOT__ call the `WasmEdge_StringDelete`.\n\n \\param Buf the buffer to copy into the WasmEdge_String object.\n \\param Len the buffer length.\n\n \\returns string object refer to the input buffer with its length."]
    pub fn WasmEdge_StringWrap(Buf: *const ::std::os::raw::c_char, Len: u32) -> WasmEdge_String;
}
extern "C" {
    #[doc = " Compare the two WasmEdge_String objects.\n\n \\param Str1 the first WasmEdge_String object to compare.\n \\param Str2 the second WasmEdge_String object to compare.\n\n \\returns true if the content of two WasmEdge_String objects are the same,\n false if not."]
    pub fn WasmEdge_StringIsEqual(Str1: WasmEdge_String, Str2: WasmEdge_String) -> bool;
}
extern "C" {
    #[doc = " Copy the content of WasmEdge_String object to the buffer.\n\n This function copy at most `Len` characters from the `WasmEdge_String`\n object to the destination buffer. If the string length is less than `Len`\n characters long, the remainder of the buffer is filled with `\\0' characters.\n Otherwise, the destination is not terminated.\n\n \\param Str the source WasmEdge_String object to copy.\n \\param Buf the buffer to fill the string content.\n \\param Len the buffer length.\n\n \\returns the copied length of string."]
    pub fn WasmEdge_StringCopy(
        Str: WasmEdge_String,
        Buf: *mut ::std::os::raw::c_char,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_String.\n\n After calling this function, the resources in the WasmEdge_String object\n will be released and the object should __NOT__ be used.\n\n \\param Str the WasmEdge_String object to destroy."]
    pub fn WasmEdge_StringDelete(Str: WasmEdge_String);
}
extern "C" {
    #[doc = " Check the result is a success or not.\n\n \\param Res the WasmEdge_Result struct.\n\n \\returns true if the error code is WasmEdge_Result_Success or\n WasmEdge_Result_Terminate, false for others."]
    pub fn WasmEdge_ResultOK(Res: WasmEdge_Result) -> bool;
}
extern "C" {
    #[doc = " Generate the result with code.\n\n \\param Category the WasmEdge_ErrCategory to specify the error category.\n \\param Code the 24-bit length error code. The data exceeds 24 bits will be\n stripped.\n\n \\returns WasmEdge_Result struct with the given data."]
    pub fn WasmEdge_ResultGen(Category: WasmEdge_ErrCategory, Code: u32) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Get the result code.\n\n \\param Res the WasmEdge_Result struct.\n\n \\returns result code (24-bit size data) in the WasmEdge_Result struct."]
    pub fn WasmEdge_ResultGetCode(Res: WasmEdge_Result) -> u32;
}
extern "C" {
    #[doc = " Get the error category.\n\n \\param Res the WasmEdge_Result struct.\n\n \\returns error category in the WasmEdge_Result struct."]
    pub fn WasmEdge_ResultGetCategory(Res: WasmEdge_Result) -> WasmEdge_ErrCategory;
}
extern "C" {
    #[doc = " Get the result message.\n\n The returned string must __NOT__ be destroyed.\n If the error category of the result is __NOT__ `WasmEdge_ErrCategory_WASM`,\n the message will always be \"user defined error code\".\n\n \\param Res the WasmEdge_Result struct.\n\n \\returns NULL-terminated C string of the corresponding error message."]
    pub fn WasmEdge_ResultGetMessage(Res: WasmEdge_Result) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Compare the two WasmEdge_Limit objects.\n\n \\param Lim1 the first WasmEdge_Limit object to compare.\n \\param Lim2 the second WasmEdge_Limit object to compare.\n\n \\returns true if the content of two WasmEdge_Limit objects are the same,\n false if not."]
    pub fn WasmEdge_LimitIsEqual(Lim1: WasmEdge_Limit, Lim2: WasmEdge_Limit) -> bool;
}
extern "C" {
    #[doc = " Creation of the WasmEdge_ConfigureContext.\n\n The caller owns the object and should call `WasmEdge_ConfigureDelete` to\n destroy it.\n\n \\returns pointer to the context, NULL if failed."]
    pub fn WasmEdge_ConfigureCreate() -> *mut WasmEdge_ConfigureContext;
}
extern "C" {
    #[doc = " Add a proposal setting into the WasmEdge_ConfigureContext.\n\n For turning on a specific WASM proposal in VM, loader, or compiler contexts,\n etc., you can set the proposal value into the WasmEdge_ConfigureContext and\n create the VM, loader, or compiler contexts, etc. with this context.\n\n ```c\n WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();\n WasmEdge_ConfigureAddProposal(Conf, WasmEdge_Proposal_BulkMemoryOperations);\n WasmEdge_ConfigureAddProposal(Conf, WasmEdge_Proposal_ReferenceTypes);\n WasmEdge_ConfigureAddProposal(Conf, WasmEdge_Proposal_SIMD);\n WasmEdge_VMContext *VM = WasmEdge_VMCreate(Conf, NULL);\n ```\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to add the proposal value.\n \\param Prop the proposal value."]
    pub fn WasmEdge_ConfigureAddProposal(
        Cxt: *mut WasmEdge_ConfigureContext,
        Prop: WasmEdge_Proposal,
    );
}
extern "C" {
    #[doc = " Remove a proposal setting in the WasmEdge_ConfigureContext.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to remove the proposal.\n \\param Prop the proposal value."]
    pub fn WasmEdge_ConfigureRemoveProposal(
        Cxt: *mut WasmEdge_ConfigureContext,
        Prop: WasmEdge_Proposal,
    );
}
extern "C" {
    #[doc = " Check if a proposal setting exists in the WasmEdge_ConfigureContext or not.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to check the proposal value.\n \\param Prop the proposal value.\n\n \\returns true if the proposal setting exists, false if not."]
    pub fn WasmEdge_ConfigureHasProposal(
        Cxt: *const WasmEdge_ConfigureContext,
        Prop: WasmEdge_Proposal,
    ) -> bool;
}
extern "C" {
    #[doc = " Add a built-in host registration setting into WasmEdge_ConfigureContext.\n\n For turning on the Wasi support in `WasmEdge_VMContext`, you can set the\n built-in host registration value into the `WasmEdge_ConfigureContext` and\n create VM with this context.\n\n ```c\n WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();\n WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);\n WasmEdge_VMContext *VM = WasmEdge_VMCreate(Conf, NULL);\n ```\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to add built-in host registration.\n \\param Host the built-in host registration value."]
    pub fn WasmEdge_ConfigureAddHostRegistration(
        Cxt: *mut WasmEdge_ConfigureContext,
        Host: WasmEdge_HostRegistration,
    );
}
extern "C" {
    #[doc = " Remove a built-in host registration setting in the\n WasmEdge_ConfigureContext.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to remove the host\n pre-registration.\n \\param Host the built-in host registration value."]
    pub fn WasmEdge_ConfigureRemoveHostRegistration(
        Cxt: *mut WasmEdge_ConfigureContext,
        Host: WasmEdge_HostRegistration,
    );
}
extern "C" {
    #[doc = " Check if a built-in host registration setting exists in the\n WasmEdge_ConfigureContext or not.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to check the host pre-registration.\n \\param Host the built-in host registration value.\n\n \\returns true if the built-in host registration setting exists, false if\n not."]
    pub fn WasmEdge_ConfigureHasHostRegistration(
        Cxt: *const WasmEdge_ConfigureContext,
        Host: WasmEdge_HostRegistration,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the page limit of memory instances.\n\n Limit the page count (64KiB per page) in memory instances.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the maximum page count.\n \\param Page the maximum page count."]
    pub fn WasmEdge_ConfigureSetMaxMemoryPage(Cxt: *mut WasmEdge_ConfigureContext, Page: u32);
}
extern "C" {
    #[doc = " Get the setting of the page limit of memory instances.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the maximum page count\n setting.\n\n \\returns the page count limitation value."]
    pub fn WasmEdge_ConfigureGetMaxMemoryPage(Cxt: *const WasmEdge_ConfigureContext) -> u32;
}
extern "C" {
    #[doc = " Set the force interpreter mode execution option.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.\n \\param isForceInterpreter the boolean value to determine to forcibly run\n WASM in interpreter mode or not."]
    pub fn WasmEdge_ConfigureSetForceInterpreter(
        Cxt: *mut WasmEdge_ConfigureContext,
        isForceInterpreter: bool,
    );
}
extern "C" {
    #[doc = " Get the force interpreter mode execution option.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.\n\n \\returns the boolean value to determine to forcibly run WASM in interpreter\n mode or not."]
    pub fn WasmEdge_ConfigureIsForceInterpreter(Cxt: *const WasmEdge_ConfigureContext) -> bool;
}
extern "C" {
    #[doc = " Set the optimization level of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the optimization level.\n \\param Level the AOT compiler optimization level."]
    pub fn WasmEdge_ConfigureCompilerSetOptimizationLevel(
        Cxt: *mut WasmEdge_ConfigureContext,
        Level: WasmEdge_CompilerOptimizationLevel,
    );
}
extern "C" {
    #[doc = " Get the optimization level of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the optimization level.\n\n \\returns the AOT compiler optimization level."]
    pub fn WasmEdge_ConfigureCompilerGetOptimizationLevel(
        Cxt: *const WasmEdge_ConfigureContext,
    ) -> WasmEdge_CompilerOptimizationLevel;
}
extern "C" {
    #[doc = " Set the output binary format of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the output binary format.\n \\param Format the AOT compiler output binary format."]
    pub fn WasmEdge_ConfigureCompilerSetOutputFormat(
        Cxt: *mut WasmEdge_ConfigureContext,
        Format: WasmEdge_CompilerOutputFormat,
    );
}
extern "C" {
    #[doc = " Get the output binary format of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the output binary format.\n\n \\returns the AOT compiler output binary format."]
    pub fn WasmEdge_ConfigureCompilerGetOutputFormat(
        Cxt: *const WasmEdge_ConfigureContext,
    ) -> WasmEdge_CompilerOutputFormat;
}
extern "C" {
    #[doc = " Set the dump IR option of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.\n \\param IsDump the boolean value to determine to dump IR or not when\n compilation in AOT compiler."]
    pub fn WasmEdge_ConfigureCompilerSetDumpIR(Cxt: *mut WasmEdge_ConfigureContext, IsDump: bool);
}
extern "C" {
    #[doc = " Get the dump IR option of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.\n\n \\returns the boolean value to determine to dump IR or not when compilation\n in AOT compiler."]
    pub fn WasmEdge_ConfigureCompilerIsDumpIR(Cxt: *const WasmEdge_ConfigureContext) -> bool;
}
extern "C" {
    #[doc = " Set the generic binary option of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.\n \\param IsGeneric the boolean value to determine to generate the generic\n binary or not when compilation in AOT compiler."]
    pub fn WasmEdge_ConfigureCompilerSetGenericBinary(
        Cxt: *mut WasmEdge_ConfigureContext,
        IsGeneric: bool,
    );
}
extern "C" {
    #[doc = " Get the generic binary option of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.\n\n \\returns the boolean value to determine to generate the generic binary or\n not when compilation in AOT compiler."]
    pub fn WasmEdge_ConfigureCompilerIsGenericBinary(Cxt: *const WasmEdge_ConfigureContext)
        -> bool;
}
extern "C" {
    #[doc = " Set the interruptible option of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.\n \\param IsInterruptible the boolean value to determine to generate\n interruptible binary or not when compilation in AOT compiler."]
    pub fn WasmEdge_ConfigureCompilerSetInterruptible(
        Cxt: *mut WasmEdge_ConfigureContext,
        IsInterruptible: bool,
    );
}
extern "C" {
    #[doc = " Get the interruptible option of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.\n\n \\returns the boolean value to determine to generate interruptible binary or\n not when compilation in AOT compiler."]
    pub fn WasmEdge_ConfigureCompilerIsInterruptible(Cxt: *const WasmEdge_ConfigureContext)
        -> bool;
}
extern "C" {
    #[doc = " Set the instruction counting option for the statistics.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.\n \\param IsCount the boolean value to determine to support instruction\n counting when execution or not after compilation by the AOT compiler."]
    pub fn WasmEdge_ConfigureStatisticsSetInstructionCounting(
        Cxt: *mut WasmEdge_ConfigureContext,
        IsCount: bool,
    );
}
extern "C" {
    #[doc = " Get the instruction counting option for the statistics.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.\n\n \\returns the boolean value to determine to support instruction counting when\n execution or not after compilation by the AOT compiler."]
    pub fn WasmEdge_ConfigureStatisticsIsInstructionCounting(
        Cxt: *const WasmEdge_ConfigureContext,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the cost measuring option for the statistics.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.\n \\param IsMeasure the boolean value to determine to support cost measuring\n when execution or not after compilation by the AOT compiler."]
    pub fn WasmEdge_ConfigureStatisticsSetCostMeasuring(
        Cxt: *mut WasmEdge_ConfigureContext,
        IsMeasure: bool,
    );
}
extern "C" {
    #[doc = " Get the cost measuring option for the statistics.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.\n\n \\returns the boolean value to determine to support cost measuring when\n execution or not after compilation by the AOT compiler."]
    pub fn WasmEdge_ConfigureStatisticsIsCostMeasuring(
        Cxt: *const WasmEdge_ConfigureContext,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the time measuring option for the statistics.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.\n \\param IsMeasure the boolean value to determine to support time when\n execution or not after compilation by the AOT compiler."]
    pub fn WasmEdge_ConfigureStatisticsSetTimeMeasuring(
        Cxt: *mut WasmEdge_ConfigureContext,
        IsMeasure: bool,
    );
}
extern "C" {
    #[doc = " Get the time measuring option for the statistics.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.\n\n \\returns the boolean value to determine to support time measuring when\n execution or not after compilation by the AOT compiler."]
    pub fn WasmEdge_ConfigureStatisticsIsTimeMeasuring(
        Cxt: *const WasmEdge_ConfigureContext,
    ) -> bool;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_ConfigureContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to destroy."]
    pub fn WasmEdge_ConfigureDelete(Cxt: *mut WasmEdge_ConfigureContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_StatisticsContext.\n\n The caller owns the object and should call `WasmEdge_StatisticsDelete` to\n destroy it.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_StatisticsCreate() -> *mut WasmEdge_StatisticsContext;
}
extern "C" {
    #[doc = " Get the instruction count in execution.\n\n \\param Cxt the WasmEdge_StatisticsContext to get data.\n\n \\returns the instruction count in total execution."]
    pub fn WasmEdge_StatisticsGetInstrCount(Cxt: *const WasmEdge_StatisticsContext) -> u64;
}
extern "C" {
    #[doc = " Get the instruction count per second in execution.\n\n \\param Cxt the WasmEdge_StatisticsContext to get data.\n\n \\returns the instruction count per second."]
    pub fn WasmEdge_StatisticsGetInstrPerSecond(Cxt: *const WasmEdge_StatisticsContext) -> f64;
}
extern "C" {
    #[doc = " Get the total cost in execution.\n\n \\param Cxt the WasmEdge_StatisticsContext to get data.\n\n \\returns the total cost."]
    pub fn WasmEdge_StatisticsGetTotalCost(Cxt: *const WasmEdge_StatisticsContext) -> u64;
}
extern "C" {
    #[doc = " Set the costs of instructions.\n\n \\param Cxt the WasmEdge_StatisticsContext to set the cost table.\n \\param CostArr the cost table array.\n \\param Len the length of the cost table array."]
    pub fn WasmEdge_StatisticsSetCostTable(
        Cxt: *mut WasmEdge_StatisticsContext,
        CostArr: *mut u64,
        Len: u32,
    );
}
extern "C" {
    #[doc = " Set the cost limit in execution.\n\n The WASM execution will be aborted if the instruction costs exceeded the\n limit and the ErrCode::Value::CostLimitExceeded will be returned.\n\n \\param Cxt the WasmEdge_StatisticsContext to set the cost table.\n \\param Limit the cost limit."]
    pub fn WasmEdge_StatisticsSetCostLimit(Cxt: *mut WasmEdge_StatisticsContext, Limit: u64);
}
extern "C" {
    #[doc = " Clear all data in the WasmEdge_StatisticsContext.\n\n \\param Cxt the WasmEdge_StatisticsContext to clear."]
    pub fn WasmEdge_StatisticsClear(Cxt: *mut WasmEdge_StatisticsContext);
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_StatisticsContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_StatisticsContext to destroy."]
    pub fn WasmEdge_StatisticsDelete(Cxt: *mut WasmEdge_StatisticsContext);
}
extern "C" {
    #[doc = " Get the length of imports list of the AST module.\n\n \\param Cxt the WasmEdge_ASTModuleContext.\n\n \\returns length of the imports list."]
    pub fn WasmEdge_ASTModuleListImportsLength(Cxt: *const WasmEdge_ASTModuleContext) -> u32;
}
extern "C" {
    #[doc = " List the imports of the AST module.\n\n If the `Imports` buffer length is smaller than the result of the imports\n list size, the overflowed return values will be discarded.\n\n \\param Cxt the WasmEdge_ASTModuleContext.\n \\param [out] Imports the import type contexts buffer. Can be NULL if import\n types are not needed.\n \\param Len the buffer length.\n\n \\returns actual exported function list size."]
    pub fn WasmEdge_ASTModuleListImports(
        Cxt: *const WasmEdge_ASTModuleContext,
        Imports: *mut *const WasmEdge_ImportTypeContext,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the length of exports list of the AST module.\n\n \\param Cxt the WasmEdge_ASTModuleContext.\n\n \\returns length of the exports list."]
    pub fn WasmEdge_ASTModuleListExportsLength(Cxt: *const WasmEdge_ASTModuleContext) -> u32;
}
extern "C" {
    #[doc = " List the exports of the AST module.\n\n If the `Exports` buffer length is smaller than the result of the exports\n list size, the overflowed return values will be discarded.\n\n \\param Cxt the WasmEdge_ASTModuleContext.\n \\param [out] Exports the export type contexts buffer. Can be NULL if export\n types are not needed.\n \\param Len the buffer length.\n\n \\returns actual exported function list size."]
    pub fn WasmEdge_ASTModuleListExports(
        Cxt: *const WasmEdge_ASTModuleContext,
        Exports: *mut *const WasmEdge_ExportTypeContext,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_ASTModuleContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_ASTModuleContext to destroy."]
    pub fn WasmEdge_ASTModuleDelete(Cxt: *mut WasmEdge_ASTModuleContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_FunctionTypeContext.\n\n The caller owns the object and should call `WasmEdge_FunctionTypeDelete` to\n destroy it.\n\n \\param ParamList the value types list of parameters. NULL if the length is\n 0.\n \\param ParamLen the ParamList buffer length.\n \\param ReturnList the value types list of returns. NULL if the length is 0.\n \\param ReturnLen the ReturnList buffer length.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_FunctionTypeCreate(
        ParamList: *const WasmEdge_ValType,
        ParamLen: u32,
        ReturnList: *const WasmEdge_ValType,
        ReturnLen: u32,
    ) -> *mut WasmEdge_FunctionTypeContext;
}
extern "C" {
    #[doc = " Get the parameter types list length from the WasmEdge_FunctionTypeContext.\n\n \\param Cxt the WasmEdge_FunctionTypeContext.\n\n \\returns the parameter types list length."]
    pub fn WasmEdge_FunctionTypeGetParametersLength(
        Cxt: *const WasmEdge_FunctionTypeContext,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the parameter types list from the WasmEdge_FunctionTypeContext.\n\n If the `List` buffer length is smaller than the length of the parameter type\n list, the overflowed values will be discarded.\n\n \\param Cxt the WasmEdge_FunctionTypeContext.\n \\param [out] List the WasmEdge_ValType buffer to fill the parameter value\n types.\n \\param Len the value type buffer length.\n\n \\returns the actual parameter types list length."]
    pub fn WasmEdge_FunctionTypeGetParameters(
        Cxt: *const WasmEdge_FunctionTypeContext,
        List: *mut WasmEdge_ValType,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the return types list length from the WasmEdge_FunctionTypeContext.\n\n \\param Cxt the WasmEdge_FunctionTypeContext.\n\n \\returns the return types list length."]
    pub fn WasmEdge_FunctionTypeGetReturnsLength(Cxt: *const WasmEdge_FunctionTypeContext) -> u32;
}
extern "C" {
    #[doc = " Get the return types list from the WasmEdge_FunctionTypeContext.\n\n If the `List` buffer length is smaller than the length of the return type\n list, the overflowed values will be discarded.\n\n \\param Cxt the WasmEdge_FunctionTypeContext.\n \\param [out] List the WasmEdge_ValType buffer to fill the return value\n types.\n \\param Len the value type buffer length.\n\n \\returns the actual return types list length."]
    pub fn WasmEdge_FunctionTypeGetReturns(
        Cxt: *const WasmEdge_FunctionTypeContext,
        List: *mut WasmEdge_ValType,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_FunctionTypeContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_FunctionTypeContext to destroy."]
    pub fn WasmEdge_FunctionTypeDelete(Cxt: *mut WasmEdge_FunctionTypeContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_TableTypeContext.\n\n The caller owns the object and should call `WasmEdge_TableTypeDelete` to\n destroy it.\n\n \\param RefType the reference type of the table type.\n \\param Limit the limit struct of the table type.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_TableTypeCreate(
        RefType: WasmEdge_RefType,
        Limit: WasmEdge_Limit,
    ) -> *mut WasmEdge_TableTypeContext;
}
extern "C" {
    #[doc = " Get the reference type from a table type.\n\n \\param Cxt the WasmEdge_TableTypeContext.\n\n \\returns the reference type of the table type."]
    pub fn WasmEdge_TableTypeGetRefType(Cxt: *const WasmEdge_TableTypeContext) -> WasmEdge_RefType;
}
extern "C" {
    #[doc = " Get the limit from a table type.\n\n \\param Cxt the WasmEdge_TableTypeContext.\n\n \\returns the limit struct of the table type."]
    pub fn WasmEdge_TableTypeGetLimit(Cxt: *const WasmEdge_TableTypeContext) -> WasmEdge_Limit;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_TableTypeContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_TableTypeContext to destroy."]
    pub fn WasmEdge_TableTypeDelete(Cxt: *mut WasmEdge_TableTypeContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_MemoryTypeContext.\n\n The caller owns the object and should call `WasmEdge_MemoryTypeDelete` to\n destroy it.\n\n \\param Limit the limit struct of the memory type.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_MemoryTypeCreate(Limit: WasmEdge_Limit) -> *mut WasmEdge_MemoryTypeContext;
}
extern "C" {
    #[doc = " Get the limit from a memory type.\n\n \\param Cxt the WasmEdge_MemoryTypeContext.\n\n \\returns the limit struct of the memory type."]
    pub fn WasmEdge_MemoryTypeGetLimit(Cxt: *const WasmEdge_MemoryTypeContext) -> WasmEdge_Limit;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_MemoryTypeContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_MemoryTypeContext to destroy."]
    pub fn WasmEdge_MemoryTypeDelete(Cxt: *mut WasmEdge_MemoryTypeContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_GlobalTypeContext.\n\n The caller owns the object and should call `WasmEdge_GlobalTypeDelete` to\n destroy it.\n\n \\param ValType the value type of the global type.\n \\param Mut the mutation of the global type.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_GlobalTypeCreate(
        ValType: WasmEdge_ValType,
        Mut: WasmEdge_Mutability,
    ) -> *mut WasmEdge_GlobalTypeContext;
}
extern "C" {
    #[doc = " Get the value type from a global type.\n\n \\param Cxt the WasmEdge_GlobalTypeContext.\n\n \\returns the value type of the global type."]
    pub fn WasmEdge_GlobalTypeGetValType(
        Cxt: *const WasmEdge_GlobalTypeContext,
    ) -> WasmEdge_ValType;
}
extern "C" {
    #[doc = " Get the mutability from a global type.\n\n \\param Cxt the WasmEdge_GlobalTypeContext.\n\n \\returns the mutability of the global type."]
    pub fn WasmEdge_GlobalTypeGetMutability(
        Cxt: *const WasmEdge_GlobalTypeContext,
    ) -> WasmEdge_Mutability;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_GlobalTypeContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_GlobalTypeContext to destroy."]
    pub fn WasmEdge_GlobalTypeDelete(Cxt: *mut WasmEdge_GlobalTypeContext);
}
extern "C" {
    #[doc = " Get the external type from an import type.\n\n \\param Cxt the WasmEdge_ImportTypeContext.\n\n \\returns the external type of the import type."]
    pub fn WasmEdge_ImportTypeGetExternalType(
        Cxt: *const WasmEdge_ImportTypeContext,
    ) -> WasmEdge_ExternalType;
}
extern "C" {
    #[doc = " Get the module name from an import type.\n\n The returned string object is linked to the module name of the import type,\n and the caller should __NOT__ call the `WasmEdge_StringDelete`.\n\n \\param Cxt the WasmEdge_ImportTypeContext.\n\n \\returns string object. Length will be 0 and Buf will be NULL if failed."]
    pub fn WasmEdge_ImportTypeGetModuleName(
        Cxt: *const WasmEdge_ImportTypeContext,
    ) -> WasmEdge_String;
}
extern "C" {
    #[doc = " Get the external name from an import type.\n\n The returned string object is linked to the external name of the import\n type, and the caller should __NOT__ call the `WasmEdge_StringDelete`.\n\n \\param Cxt the WasmEdge_ImportTypeContext.\n\n \\returns string object. Length will be 0 and Buf will be NULL if failed."]
    pub fn WasmEdge_ImportTypeGetExternalName(
        Cxt: *const WasmEdge_ImportTypeContext,
    ) -> WasmEdge_String;
}
extern "C" {
    #[doc = " Get the external value (which is function type) from an import type.\n\n The import type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The function type context links to the function type in the import type\n context and the AST module context. The caller should __NOT__ call the\n `WasmEdge_FunctionTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ImportTypeContext which queried from the `ASTCxt`.\n\n \\returns the function type. NULL if failed or the external type of the\n import type is not `WasmEdge_ExternalType_Function`."]
    pub fn WasmEdge_ImportTypeGetFunctionType(
        ASTCxt: *const WasmEdge_ASTModuleContext,
        Cxt: *const WasmEdge_ImportTypeContext,
    ) -> *const WasmEdge_FunctionTypeContext;
}
extern "C" {
    #[doc = " Get the external value (which is table type) from an import type.\n\n The import type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The table type context links to the table type in the import type context\n and the AST module context. The caller should __NOT__ call the\n `WasmEdge_TableTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ImportTypeContext which queried from the `ASTCxt`.\n\n \\returns the table type. NULL if failed or the external type of the import\n type is not `WasmEdge_ExternalType_Table`."]
    pub fn WasmEdge_ImportTypeGetTableType(
        ASTCxt: *const WasmEdge_ASTModuleContext,
        Cxt: *const WasmEdge_ImportTypeContext,
    ) -> *const WasmEdge_TableTypeContext;
}
extern "C" {
    #[doc = " Get the external value (which is memory type) from an import type.\n\n The import type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The memory type context links to the memory type in the import type context\n and the AST module context. The caller should __NOT__ call the\n `WasmEdge_MemoryTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ImportTypeContext which queried from the `ASTCxt`.\n\n \\returns the memory type. NULL if failed or the external type of the import\n type is not `WasmEdge_ExternalType_Memory`."]
    pub fn WasmEdge_ImportTypeGetMemoryType(
        ASTCxt: *const WasmEdge_ASTModuleContext,
        Cxt: *const WasmEdge_ImportTypeContext,
    ) -> *const WasmEdge_MemoryTypeContext;
}
extern "C" {
    #[doc = " Get the external value (which is global type) from an import type.\n\n The import type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The global type context links to the global type in the import type context\n and the AST module context. The caller should __NOT__ call the\n `WasmEdge_GlobalTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ImportTypeContext which queried from the `ASTCxt`.\n\n \\returns the global type. NULL if failed or the external type of the import\n type is not `WasmEdge_ExternalType_Global`."]
    pub fn WasmEdge_ImportTypeGetGlobalType(
        ASTCxt: *const WasmEdge_ASTModuleContext,
        Cxt: *const WasmEdge_ImportTypeContext,
    ) -> *const WasmEdge_GlobalTypeContext;
}
extern "C" {
    #[doc = " Get the external type from an export type.\n\n \\param Cxt the WasmEdge_ExportTypeContext.\n\n \\returns the external type of the export type."]
    pub fn WasmEdge_ExportTypeGetExternalType(
        Cxt: *const WasmEdge_ExportTypeContext,
    ) -> WasmEdge_ExternalType;
}
extern "C" {
    #[doc = " Get the external name from an export type.\n\n The returned string object is linked to the external name of the export\n type, and the caller should __NOT__ call the `WasmEdge_StringDelete`.\n\n \\param Cxt the WasmEdge_ExportTypeContext.\n\n \\returns string object. Length will be 0 and Buf will be NULL if failed."]
    pub fn WasmEdge_ExportTypeGetExternalName(
        Cxt: *const WasmEdge_ExportTypeContext,
    ) -> WasmEdge_String;
}
extern "C" {
    #[doc = " Get the external value (which is function type) from an export type.\n\n The export type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The function type context links to the function type in the export type\n context and the AST module context. The caller should __NOT__ call the\n `WasmEdge_FunctionTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ExportTypeContext which queried from the `ASTCxt`.\n\n \\returns the function type. NULL if failed or the external type of the\n export type is not `WasmEdge_ExternalType_Function`."]
    pub fn WasmEdge_ExportTypeGetFunctionType(
        ASTCxt: *const WasmEdge_ASTModuleContext,
        Cxt: *const WasmEdge_ExportTypeContext,
    ) -> *const WasmEdge_FunctionTypeContext;
}
extern "C" {
    #[doc = " Get the external value (which is table type) from an export type.\n\n The export type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The table type context links to the table type in the export type context\n and the AST module context. The caller should __NOT__ call the\n `WasmEdge_TableTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ExportTypeContext which queried from the `ASTCxt`.\n\n \\returns the table type. NULL if failed or the external type of the export\n type is not `WasmEdge_ExternalType_Table`."]
    pub fn WasmEdge_ExportTypeGetTableType(
        ASTCxt: *const WasmEdge_ASTModuleContext,
        Cxt: *const WasmEdge_ExportTypeContext,
    ) -> *const WasmEdge_TableTypeContext;
}
extern "C" {
    #[doc = " Get the external value (which is memory type) from an export type.\n\n The export type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The memory type context links to the memory type in the export type context\n and the AST module context. The caller should __NOT__ call the\n `WasmEdge_MemoryTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ExportTypeContext which queried from the `ASTCxt`.\n\n \\returns the memory type. NULL if failed or the external type of the export\n type is not `WasmEdge_ExternalType_Memory`."]
    pub fn WasmEdge_ExportTypeGetMemoryType(
        ASTCxt: *const WasmEdge_ASTModuleContext,
        Cxt: *const WasmEdge_ExportTypeContext,
    ) -> *const WasmEdge_MemoryTypeContext;
}
extern "C" {
    #[doc = " Get the external value (which is global type) from an export type.\n\n The export type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The global type context links to the global type in the export type context\n and the AST module context. The caller should __NOT__ call the\n `WasmEdge_GlobalTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ExportTypeContext which queried from the `ASTCxt`.\n\n \\returns the global type. NULL if failed or the external type of the export\n type is not `WasmEdge_ExternalType_Global`."]
    pub fn WasmEdge_ExportTypeGetGlobalType(
        ASTCxt: *const WasmEdge_ASTModuleContext,
        Cxt: *const WasmEdge_ExportTypeContext,
    ) -> *const WasmEdge_GlobalTypeContext;
}
extern "C" {
    #[doc = " Creation of the WasmEdge_CompilerContext.\n\n The caller owns the object and should call `WasmEdge_CompilerDelete` to\n delete it.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_CompilerCreate(
        ConfCxt: *const WasmEdge_ConfigureContext,
    ) -> *mut WasmEdge_CompilerContext;
}
extern "C" {
    #[doc = " Compile the input WASM from the file path.\n\n The compiler compiles the WASM from file path for the ahead-of-time mode and\n store the result to the output file path.\n\n \\param Cxt the WasmEdge_CompilerContext.\n \\param InPath the input WASM file path.\n \\param OutPath the output WASM file path.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_CompilerCompile(
        Cxt: *mut WasmEdge_CompilerContext,
        InPath: *const ::std::os::raw::c_char,
        OutPath: *const ::std::os::raw::c_char,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Compile the input WASM from the given buffer.\n\n The compiler compiles the WASM from the given buffer for the\n ahead-of-time mode and store the result to the output file path.\n\n \\param Cxt the WasmEdge_CompilerContext.\n \\param InBuffer the input WASM binary buffer.\n \\param InBufferLen the length of the input WASM binary buffer.\n \\param OutPath the output WASM file path.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_CompilerCompileFromBuffer(
        Cxt: *mut WasmEdge_CompilerContext,
        InBuffer: *const u8,
        InBufferLen: u64,
        OutPath: *const ::std::os::raw::c_char,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_CompilerContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_CompilerContext to destroy."]
    pub fn WasmEdge_CompilerDelete(Cxt: *mut WasmEdge_CompilerContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_LoaderContext.\n\n The caller owns the object and should call `WasmEdge_LoaderDelete` to\n destroy it.\n\n \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of Loader.\n NULL for the default configuration.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_LoaderCreate(
        ConfCxt: *const WasmEdge_ConfigureContext,
    ) -> *mut WasmEdge_LoaderContext;
}
extern "C" {
    #[doc = " Load and parse the WASM module from a WASM file into a\n WasmEdge_ASTModuleContext.\n\n Load and parse the WASM module from the file path, and return a\n `WasmEdge_ASTModuleContext` as the result. The caller owns the\n `WasmEdge_ASTModuleContext` object and should call\n `WasmEdge_ASTModuleDelete` to destroy it.\n\n \\param Cxt the WasmEdge_LoaderContext.\n \\param [out] Module the output WasmEdge_ASTModuleContext if succeeded.\n \\param Path the NULL-terminated C string of the WASM file path.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_LoaderParseFromFile(
        Cxt: *mut WasmEdge_LoaderContext,
        Module: *mut *mut WasmEdge_ASTModuleContext,
        Path: *const ::std::os::raw::c_char,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Load and parse the WASM module from a buffer into WasmEdge_ASTModuleContext.\n\n Load and parse the WASM module from a buffer, and return a\n WasmEdge_ASTModuleContext as the result. The caller owns the\n WasmEdge_ASTModuleContext object and should call `WasmEdge_ASTModuleDelete`\n to destroy it.\n\n \\param Cxt the WasmEdge_LoaderContext.\n \\param [out] Module the output WasmEdge_ASTModuleContext if succeeded.\n \\param Buf the buffer of WASM binary.\n \\param BufLen the length of the buffer.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_LoaderParseFromBuffer(
        Cxt: *mut WasmEdge_LoaderContext,
        Module: *mut *mut WasmEdge_ASTModuleContext,
        Buf: *const u8,
        BufLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_LoaderContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_LoaderContext to destroy."]
    pub fn WasmEdge_LoaderDelete(Cxt: *mut WasmEdge_LoaderContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_ValidatorContext.\n\n The caller owns the object and should call `WasmEdge_ValidatorDelete` to\n destroy it.\n\n \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of\n Validator. NULL for the default configuration.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_ValidatorCreate(
        ConfCxt: *const WasmEdge_ConfigureContext,
    ) -> *mut WasmEdge_ValidatorContext;
}
extern "C" {
    #[doc = " Validate the WasmEdge AST Module.\n\n \\param Cxt the WasmEdge_ValidatorContext.\n \\param ASTCxt the WasmEdge_ASTModuleContext to validate.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_ValidatorValidate(
        Cxt: *mut WasmEdge_ValidatorContext,
        ASTCxt: *const WasmEdge_ASTModuleContext,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_ValidatorContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_ValidatorContext to destroy."]
    pub fn WasmEdge_ValidatorDelete(Cxt: *mut WasmEdge_ValidatorContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_ExecutorContext.\n\n The caller owns the object and should call `WasmEdge_ExecutorDelete` to\n delete it.\n\n \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of\n Executor. NULL for the default configuration.\n \\param StatCxt the WasmEdge_StatisticsContext as the statistics object set\n into Executor. The statistics will refer to this context, and the life cycle\n should be guaranteed until the executor context is deleted. NULL for not\n doing the statistics.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_ExecutorCreate(
        ConfCxt: *const WasmEdge_ConfigureContext,
        StatCxt: *mut WasmEdge_StatisticsContext,
    ) -> *mut WasmEdge_ExecutorContext;
}
extern "C" {
    #[doc = " Instantiate an AST Module into a module instance.\n\n Instantiate an AST Module, and return an instantiated module instance\n context as the result. The caller owns the object and should call\n `WasmEdge_ModuleInstanceDelete` to destroy it. Developers can use the\n `WasmEdge_ModuleInstanceListFunction`,\n `WasmEdge_ModuleInstanceFindFunction`, etc. APIs to retrieve the exported\n instances from the result module instance.\n\n \\param Cxt the WasmEdge_ExecutorContext to instantiate the module.\n \\param [out] ModuleCxt the output WasmEdge_ModuleInstanceContext if\n succeeded.\n \\param StoreCxt the WasmEdge_StoreContext to link the imports.\n \\param ASTCxt the WasmEdge AST Module context generated by loader or\n compiler.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_ExecutorInstantiate(
        Cxt: *mut WasmEdge_ExecutorContext,
        ModuleCxt: *mut *mut WasmEdge_ModuleInstanceContext,
        StoreCxt: *mut WasmEdge_StoreContext,
        ASTCxt: *const WasmEdge_ASTModuleContext,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Instantiate an AST Module into a named module instance and link into store.\n\n Instantiate an AST Module with the module name, return the instantiated\n module instance context as the result, and also register the module instance\n to the store. The caller owns the object and should call\n `WasmEdge_ModuleInstanceDelete` to destroy it.\n Developers can use the `WasmEdge_ModuleInstanceListFunction`,\n `WasmEdge_ModuleInstanceFindFunction`, etc. APIs to retrieve the exported\n instances from the result module instance.\n After calling this function, the output module instance will also be\n registered into the store, and the other modules can import the exported\n instances for linking when instantiation. Developers SHOULD guarantee the\n life cycle of this output module instance, or the error will occur when in\n execution after the module instance being destroyed if it has been imported\n by other modules. That is, developers have the responsibility to delete the\n output module instance even though the store being destroyed. When the\n module instance is deleted, it will be unregistered to the store\n automatically.\n\n \\param Cxt the WasmEdge_ExecutorContext to instantiate the module.\n \\param [out] ModuleCxt the output WasmEdge_ModuleInstanceContext if\n succeeded.\n \\param StoreCxt the WasmEdge_StoreContext to link the imports.\n \\param ASTCxt the WasmEdge AST Module context generated by loader or\n compiler.\n \\param ModuleName the module name WasmEdge_String for all exported\n instances.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_ExecutorRegister(
        Cxt: *mut WasmEdge_ExecutorContext,
        ModuleCxt: *mut *mut WasmEdge_ModuleInstanceContext,
        StoreCxt: *mut WasmEdge_StoreContext,
        ASTCxt: *const WasmEdge_ASTModuleContext,
        ModuleName: WasmEdge_String,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Register a module instance into a store with exporting its module name.\n\n Register an existing module into the store with its module name.\n After calling this function, the existing module instance will be registered\n into the store, and the other modules can import the exported instances for\n linking when instantiation. Developers SHOULD guarantee the life cycle of\n this existing module instance, or the error will occur when in execution\n after the module instance being destroyed if it has been imported by other\n modules. When the module instance is deleted, it will be unregistered to the\n store automatically.\n\n \\param Cxt the WasmEdge_ExecutorContext to instantiate the module.\n \\param StoreCxt the WasmEdge_StoreContext to store the instantiated module.\n \\param ImportCxt the WasmEdge_ModuleInstanceContext to register.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_ExecutorRegisterImport(
        Cxt: *mut WasmEdge_ExecutorContext,
        StoreCxt: *mut WasmEdge_StoreContext,
        ImportCxt: *const WasmEdge_ModuleInstanceContext,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Invoke a WASM function by the function instance.\n\n After instantiating a WASM module, developers can get the function instance\n context from the module instance. Then developers can invoke the function\n through this API.\n\n \\param Cxt the WasmEdge_ExecutorContext.\n \\param FuncCxt the function instance context to invoke.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n \\param [out] Returns the WasmEdge_Value buffer to fill the return values.\n \\param ReturnLen the return buffer length.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_ExecutorInvoke(
        Cxt: *mut WasmEdge_ExecutorContext,
        FuncCxt: *const WasmEdge_FunctionInstanceContext,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Asynchronous invoke a WASM function by the function instance.\n\n After instantiating a WASM module, developers can get the function instance\n context from the module instance. Then developers can invoke the function\n asynchronously through this API.\n\n \\param Cxt the WasmEdge_ExecutorContext.\n \\param FuncCxt the function instance context to invoke.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n\n \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call\n `WasmEdge_AsyncDelete` to destroy this object."]
    pub fn WasmEdge_ExecutorAsyncInvoke(
        Cxt: *mut WasmEdge_ExecutorContext,
        FuncCxt: *const WasmEdge_FunctionInstanceContext,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
    ) -> *mut WasmEdge_Async;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_ExecutorContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_ExecutorContext to destroy."]
    pub fn WasmEdge_ExecutorDelete(Cxt: *mut WasmEdge_ExecutorContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_StoreContext.\n\n The caller owns the object and should call `WasmEdge_StoreDelete` to destroy\n it.\n The store is the linker for multiple WASM module instances. The store will\n not own any module instance registered into it, and the module instances\n will automatically be unregistered if they are destroyed.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_StoreCreate() -> *mut WasmEdge_StoreContext;
}
extern "C" {
    #[doc = " Get the module instance context by the module name.\n\n After registering a WASM module, developers can call this function to find\n and get the registered module instance context by the module name.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_StoreContext.\n \\param Name the module name WasmEdge_String.\n\n \\returns pointer to the module instance context. NULL if not found."]
    pub fn WasmEdge_StoreFindModule(
        Cxt: *const WasmEdge_StoreContext,
        Name: WasmEdge_String,
    ) -> *const WasmEdge_ModuleInstanceContext;
}
extern "C" {
    #[doc = " Get the length of registered module list in store.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_StoreContext.\n\n \\returns length of registered named module list."]
    pub fn WasmEdge_StoreListModuleLength(Cxt: *const WasmEdge_StoreContext) -> u32;
}
extern "C" {
    #[doc = " List the registered module names.\n\n This function will list all registered module names.\n The returned module names filled into the `Names` array are linked to the\n registered module names in the store context, and the caller should __NOT__\n call the `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the registered\n named module list size, the overflowed return values will be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_StoreContext.\n \\param [out] Names the output names WasmEdge_String buffer of named modules.\n \\param Len the buffer length.\n\n \\returns actual registered named module list size."]
    pub fn WasmEdge_StoreListModule(
        Cxt: *const WasmEdge_StoreContext,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_StoreContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n If there are module instances registered into this store context, they will\n be automatically un-link to this store context.\n\n \\param Cxt the WasmEdge_StoreContext to destroy."]
    pub fn WasmEdge_StoreDelete(Cxt: *mut WasmEdge_StoreContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_ModuleInstanceContext.\n\n Create a module instance context with exported module name for host\n instances. Developer can use this API to create a module instance for\n collecting host functions, tables, memories, and globals.\n The caller owns the object and should call `WasmEdge_ModuleInstanceDelete`\n to destroy it.\n\n \\param ModuleName the module name WasmEdge_String of this host module to\n import.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_ModuleInstanceCreate(
        ModuleName: WasmEdge_String,
    ) -> *mut WasmEdge_ModuleInstanceContext;
}
extern "C" {
    #[doc = " Creation of the WasmEdge_ModuleInstanceContext with host data.\n\n Create a module instance context with exported module name, host data, and\n host data finalizer for host instances. Developer can use this API to create\n a module instance for collecting host functions, tables, memories, and\n globals. When this created module instance being destroyed, the host data\n finalizer will be invoked. The caller owns the object and should call\n `WasmEdge_ModuleInstanceDelete` to destroy it.\n\n \\param ModuleName the module name WasmEdge_String of this host module to\n import.\n \\param HostData the host data to set into the module instance. When calling\n the finalizer, this pointer will become the argument of the finalizer\n function.\n \\param Finalizer the function to finalize the host data.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_ModuleInstanceCreateWithData(
        ModuleName: WasmEdge_String,
        HostData: *mut ::std::os::raw::c_void,
        Finalizer: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> *mut WasmEdge_ModuleInstanceContext;
}
extern "C" {
    #[doc = " Creation of the WasmEdge_ModuleInstanceContext for the WASI specification.\n\n This function will create a WASI host module that contains the WASI host\n functions and initialize it. The caller owns the object and should call\n `WasmEdge_ModuleInstanceDelete` to destroy it.\n\n \\param Args the command line arguments. The first argument suggests being\n the program name. NULL if the length is 0.\n \\param ArgLen the length of the command line arguments.\n \\param Envs the environment variables in the format `ENV=VALUE`. NULL if the\n length is 0.\n \\param EnvLen the length of the environment variables.\n \\param Preopens the directory paths to preopen. String format in\n `PATH1:PATH2` means the path mapping, or the same path will be mapped. NULL\n if the length is 0.\n \\param PreopenLen the length of the directory paths to preopen.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_ModuleInstanceCreateWASI(
        Args: *const *const ::std::os::raw::c_char,
        ArgLen: u32,
        Envs: *const *const ::std::os::raw::c_char,
        EnvLen: u32,
        Preopens: *const *const ::std::os::raw::c_char,
        PreopenLen: u32,
    ) -> *mut WasmEdge_ModuleInstanceContext;
}
extern "C" {
    #[doc = " Initialize the WasmEdge_ModuleInstanceContext for the WASI specification.\n\n This function will initialize the WASI host module with the parameters.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext of WASI import object.\n \\param Args the command line arguments. The first argument suggests being\n the program name. NULL if the length is 0.\n \\param ArgLen the length of the command line arguments.\n \\param Envs the environment variables in the format `ENV=VALUE`. NULL if the\n length is 0.\n \\param EnvLen the length of the environment variables.\n \\param Preopens the directory paths to preopen. String format in\n `PATH1:PATH2` means the path mapping, or the same path will be mapped. NULL\n if the length is 0.\n \\param PreopenLen the length of the directory paths to preopen."]
    pub fn WasmEdge_ModuleInstanceInitWASI(
        Cxt: *mut WasmEdge_ModuleInstanceContext,
        Args: *const *const ::std::os::raw::c_char,
        ArgLen: u32,
        Envs: *const *const ::std::os::raw::c_char,
        EnvLen: u32,
        Preopens: *const *const ::std::os::raw::c_char,
        PreopenLen: u32,
    );
}
extern "C" {
    #[doc = " Get the WASI exit code.\n\n This function will return the exit code after running the \"_start\" function\n of a `wasm32-wasi` program.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext of WASI import object.\n\n \\returns the exit code after executing the \"_start\" function. Return\n `EXIT_FAILURE` if the `Cxt` is NULL or not a WASI host module."]
    pub fn WasmEdge_ModuleInstanceWASIGetExitCode(
        Cxt: *const WasmEdge_ModuleInstanceContext,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the native handler from the WASI mapped FD/Handler.\n\n This function will return the raw FD/Handler from a given mapped Fd\n or Handler.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext of WASI import object.\n \\param Fd the WASI mapped Fd.\n \\param [out] NativeHandler the raw Fd/Handler.\n\n \\returns the error code. Return `0` if the Native Handler is found.\n Return `1` if the `Cxt` is `NULL`.\n Return `2` if the given mapped Fd/handler is not found."]
    pub fn WasmEdge_ModuleInstanceWASIGetNativeHandler(
        Cxt: *const WasmEdge_ModuleInstanceContext,
        Fd: i32,
        NativeHandler: *mut u64,
    ) -> u32;
}
extern "C" {
    #[doc = " Initialize the WasmEdge_ModuleInstanceContext for the wasmedge_process\n specification.\n\n This function will initialize the wasmedge_process host module with the\n parameters.\n\n \\param AllowedCmds the allowed commands white list. NULL if the\n length is 0.\n \\param CmdsLen the length of the allowed commands white list.\n \\param AllowAll the boolean value to allow all commands. `false` is\n suggested. If this value is `true`, the allowed commands white list will not\n be recorded and all commands can be executed by wasmedge_process."]
    pub fn WasmEdge_ModuleInstanceInitWasmEdgeProcess(
        AllowedCmds: *const *const ::std::os::raw::c_char,
        CmdsLen: u32,
        AllowAll: bool,
    );
}
extern "C" {
    #[doc = " Get the export module name of a module instance.\n\n The returned string object is linked to the module name of the module\n instance, and the caller should __NOT__ call the `WasmEdge_StringDelete`.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n\n \\returns string object. Length will be 0 and Buf will be NULL if failed."]
    pub fn WasmEdge_ModuleInstanceGetModuleName(
        Cxt: *const WasmEdge_ModuleInstanceContext,
    ) -> WasmEdge_String;
}
extern "C" {
    #[doc = " Get the host data set into the module instance when creating.\n\n The returned data is owned by the module instance, and will be passed into\n the finalizer when deleting this module instance.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n\n \\returns host data. NULL if the module instance context is NULL or no host\n data set into the module instance."]
    pub fn WasmEdge_ModuleInstanceGetHostData(
        Cxt: *const WasmEdge_ModuleInstanceContext,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get the exported function instance context of a module instance.\n\n The result function instance context links to the function instance in the\n module instance context and owned by the module instance context, and the\n caller should __NOT__ call the `WasmEdge_FunctionInstanceDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param Name the function name WasmEdge_String.\n\n \\returns pointer to the function instance context. NULL if not found."]
    pub fn WasmEdge_ModuleInstanceFindFunction(
        Cxt: *const WasmEdge_ModuleInstanceContext,
        Name: WasmEdge_String,
    ) -> *mut WasmEdge_FunctionInstanceContext;
}
extern "C" {
    #[doc = " Get the exported table instance context of a module instance.\n\n The result table instance context links to the table instance in the module\n instance context and owned by the module instance context, and the caller\n should __NOT__ call the `WasmEdge_TableInstanceDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param Name the table name WasmEdge_String.\n\n \\returns pointer to the table instance context. NULL if not found."]
    pub fn WasmEdge_ModuleInstanceFindTable(
        Cxt: *const WasmEdge_ModuleInstanceContext,
        Name: WasmEdge_String,
    ) -> *mut WasmEdge_TableInstanceContext;
}
extern "C" {
    #[doc = " Get the exported memory instance context of a module instance.\n\n The result memory instance context links to the memory instance in the\n module instance context and owned by the module instance context, and the\n caller should __NOT__ call the `WasmEdge_MemoryInstanceDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param Name the memory name WasmEdge_String.\n\n \\returns pointer to the memory instance context. NULL if not found."]
    pub fn WasmEdge_ModuleInstanceFindMemory(
        Cxt: *const WasmEdge_ModuleInstanceContext,
        Name: WasmEdge_String,
    ) -> *mut WasmEdge_MemoryInstanceContext;
}
extern "C" {
    #[doc = " Get the exported global instance context of a module instance.\n\n The result global instance context links to the global instance in the\n module instance context and owned by the module instance context, and the\n caller should __NOT__ call the `WasmEdge_GlobalInstanceDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param Name the global name WasmEdge_String.\n\n \\returns pointer to the global instance context. NULL if not found."]
    pub fn WasmEdge_ModuleInstanceFindGlobal(
        Cxt: *const WasmEdge_ModuleInstanceContext,
        Name: WasmEdge_String,
    ) -> *mut WasmEdge_GlobalInstanceContext;
}
extern "C" {
    #[doc = " Get the length of exported function list of a module instance.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n\n \\returns length of the exported function list."]
    pub fn WasmEdge_ModuleInstanceListFunctionLength(
        Cxt: *const WasmEdge_ModuleInstanceContext,
    ) -> u32;
}
extern "C" {
    #[doc = " List the exported function names of a module instance.\n\n The returned function names filled into the `Names` array are linked to the\n exported names of functions of the module instance context, and the caller\n should __NOT__ call the `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the exported\n function list size, the overflowed return values will be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param [out] Names the output WasmEdge_String buffer of the function names.\n \\param Len the buffer length.\n\n \\returns actual exported function list size."]
    pub fn WasmEdge_ModuleInstanceListFunction(
        Cxt: *const WasmEdge_ModuleInstanceContext,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the length of exported table list of a module instance.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n\n \\returns length of the exported table list."]
    pub fn WasmEdge_ModuleInstanceListTableLength(
        Cxt: *const WasmEdge_ModuleInstanceContext,
    ) -> u32;
}
extern "C" {
    #[doc = " List the exported table names of a module instance.\n\n The returned table names filled into the `Names` array are linked to the\n exported names of tables of the module instance context, and the caller\n should __NOT__ call the `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the exported\n table list size, the overflowed return values will be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param [out] Names the output WasmEdge_String buffer of the table names.\n \\param Len the buffer length.\n\n \\returns actual exported table list size."]
    pub fn WasmEdge_ModuleInstanceListTable(
        Cxt: *const WasmEdge_ModuleInstanceContext,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the length of exported memory list of a module instance.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n\n \\returns length of the exported memory list."]
    pub fn WasmEdge_ModuleInstanceListMemoryLength(
        Cxt: *const WasmEdge_ModuleInstanceContext,
    ) -> u32;
}
extern "C" {
    #[doc = " List the exported memory names of a module instance.\n\n The returned memory names filled into the `Names` array are linked to the\n exported names of memories of the module instance context, and the caller\n should __NOT__ call the `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the exported\n memory list size, the overflowed return values will be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param [out] Names the output WasmEdge_String buffer of the memory names.\n \\param Len the buffer length.\n\n \\returns actual exported memory list size."]
    pub fn WasmEdge_ModuleInstanceListMemory(
        Cxt: *const WasmEdge_ModuleInstanceContext,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the length of exported global list of a module instance.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n\n \\returns length of the exported global list."]
    pub fn WasmEdge_ModuleInstanceListGlobalLength(
        Cxt: *const WasmEdge_ModuleInstanceContext,
    ) -> u32;
}
extern "C" {
    #[doc = " List the exported global names of a module instance.\n\n The returned global names filled into the `Names` array are linked to the\n exported names of globals of the module instance context, and the caller\n should __NOT__ call the `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the exported\n global list size, the overflowed return values will be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param [out] Names the output WasmEdge_String buffer of the global names.\n \\param Len the buffer length.\n\n \\returns actual exported global list size."]
    pub fn WasmEdge_ModuleInstanceListGlobal(
        Cxt: *const WasmEdge_ModuleInstanceContext,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Add a function instance context into a WasmEdge_ModuleInstanceContext.\n\n Export and move the ownership of the function instance into the module\n instance. The caller should __NOT__ access or destroy the function instance\n context after calling this function.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext to add the function instance.\n \\param Name the export function name WasmEdge_String.\n \\param FuncCxt the WasmEdge_FunctionInstanceContext to add."]
    pub fn WasmEdge_ModuleInstanceAddFunction(
        Cxt: *mut WasmEdge_ModuleInstanceContext,
        Name: WasmEdge_String,
        FuncCxt: *mut WasmEdge_FunctionInstanceContext,
    );
}
extern "C" {
    #[doc = " Add a table instance context into a WasmEdge_ModuleInstanceContext.\n\n Export and move the ownership of the table instance into the module\n instance. The caller should __NOT__ access or destroy the table instance\n context after calling this function.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext to add the table instance.\n \\param Name the export table name WasmEdge_String.\n \\param TableCxt the WasmEdge_TableInstanceContext to add."]
    pub fn WasmEdge_ModuleInstanceAddTable(
        Cxt: *mut WasmEdge_ModuleInstanceContext,
        Name: WasmEdge_String,
        TableCxt: *mut WasmEdge_TableInstanceContext,
    );
}
extern "C" {
    #[doc = " Add a memory instance context into a WasmEdge_ModuleInstanceContext.\n\n Export and move the ownership of the memory instance into the module\n instance. The caller should __NOT__ access or destroy the memory instance\n context after calling this function.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext to add the memory instance.\n \\param Name the export memory name WasmEdge_String.\n \\param MemoryCxt the WasmEdge_MemoryInstanceContext to add."]
    pub fn WasmEdge_ModuleInstanceAddMemory(
        Cxt: *mut WasmEdge_ModuleInstanceContext,
        Name: WasmEdge_String,
        MemoryCxt: *mut WasmEdge_MemoryInstanceContext,
    );
}
extern "C" {
    #[doc = " Add a global instance context into a WasmEdge_ModuleInstanceContext.\n\n Export and move the ownership of the global instance into the module\n instance. The caller should __NOT__ access or destroy the global instance\n context after calling this function.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext to add the global instance.\n \\param Name the export global name WasmEdge_String.\n \\param GlobalCxt the WasmEdge_GlobalInstanceContext to add."]
    pub fn WasmEdge_ModuleInstanceAddGlobal(
        Cxt: *mut WasmEdge_ModuleInstanceContext,
        Name: WasmEdge_String,
        GlobalCxt: *mut WasmEdge_GlobalInstanceContext,
    );
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_ModuleInstanceContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n If the module instance has been registered into one or more store contexts,\n it will be automatically unregistered.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext to destroy."]
    pub fn WasmEdge_ModuleInstanceDelete(Cxt: *mut WasmEdge_ModuleInstanceContext);
}
pub type WasmEdge_HostFunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        Data: *mut ::std::os::raw::c_void,
        CallFrameCxt: *const WasmEdge_CallingFrameContext,
        Params: *const WasmEdge_Value,
        Returns: *mut WasmEdge_Value,
    ) -> WasmEdge_Result,
>;
extern "C" {
    #[doc = " Creation of the WasmEdge_FunctionInstanceContext for host functions.\n\n The caller owns the object and should call `WasmEdge_FunctionInstanceDelete`\n to destroy it if the returned object is not added into a\n `WasmEdge_ModuleInstanceContext`. The following is an example to create a\n host function context.\n ```c\n WasmEdge_Result FuncAdd(void *Data,\n                         const WasmEdge_CallingFrameContext *CallFrameCxt,\n                         const WasmEdge_Value *In, WasmEdge_Value *Out) {\n   // Function to return A + B.\n   int32_t A = WasmEdge_ValueGetI32(In[0]);\n   int32_t B = WasmEdge_ValueGetI32(In[1]);\n   Out[0] = WasmEdge_ValueGenI32(A + B);\n   // Return execution status\n   return WasmEdge_Result_Success;\n }\n\n enum WasmEdge_ValType Params[2] = {WasmEdge_ValType_I32,\n                                    WasmEdge_ValType_I32};\n enum WasmEdge_ValType Returns[1] = {WasmEdge_ValType_I32};\n WasmEdge_FunctionTypeContext *FuncType =\n     WasmEdge_FunctionTypeCreate(Params, 2, Returns, 1);\n WasmEdge_FunctionInstanceContext *HostFunc =\n     WasmEdge_FunctionInstanceCreate(FuncType, FuncAdd, NULL, 0);\n WasmEdge_FunctionTypeDelete(FuncType);\n ...\n ```\n\n \\param Type the function type context to describe the host function\n signature.\n \\param HostFunc the host function pointer. The host function signature must\n be as following:\n ```c\n typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(\n     void *Data,\n     const WasmEdge_CallingFrameContext *CallFrameCxt,\n     const WasmEdge_Value *Params,\n     WasmEdge_Value *Returns);\n ```\n The `Params` is the input parameters array with length guaranteed to be the\n same as the parameter types in the `Type`. The `Returns` is the output\n results array with length guaranteed to be the same as the result types in\n the `Type`. The return value is `WasmEdge_Result` for the execution status.\n \\param Data the additional object, such as the pointer to a data structure,\n to set to this host function context. The caller should guarantee the life\n cycle of the object. NULL if the additional data object is not needed.\n \\param Cost the function cost in statistics. Pass 0 if the calculation is\n not needed.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_FunctionInstanceCreate(
        Type: *const WasmEdge_FunctionTypeContext,
        HostFunc: WasmEdge_HostFunc_t,
        Data: *mut ::std::os::raw::c_void,
        Cost: u64,
    ) -> *mut WasmEdge_FunctionInstanceContext;
}
pub type WasmEdge_WrapFunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        This: *mut ::std::os::raw::c_void,
        Data: *mut ::std::os::raw::c_void,
        CallFrameCxt: *const WasmEdge_CallingFrameContext,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result,
>;
extern "C" {
    #[doc = " Creation of the WasmEdge_FunctionInstanceContext for host functions.\n\n This function is for the languages which cannot pass the function pointer of\n the host function into this shared library directly. The caller owns the\n object and should call `WasmEdge_FunctionInstanceDelete` to destroy it if\n the returned object is not added into a `WasmEdge_ModuleInstanceContext`.\n The following is an example to create a host function context for other\n languages.\n ```c\n // `RealFunc` is the pointer to the function in other languages.\n\n WasmEdge_Result FuncAddWrap(\n     void *This, void *Data,\n     const WasmEdge_CallingFrameContext *CallFrameCxt,\n     const WasmEdge_Value *In, const uint32_t InLen, WasmEdge_Value *Out,\n     const uint32_t OutLen) {\n   // Wrapper function of host function to return A + B.\n\n   // `This` is the same as `RealFunc`.\n   int32_t A = WasmEdge_ValueGetI32(In[0]);\n   int32_t B = WasmEdge_ValueGetI32(In[1]);\n\n   // Call the function of `This` in the host language ...\n   int32_t Result = ...;\n\n   Out[0] = Result;\n   // Return the execution status.\n   return WasmEdge_Result_Success;\n }\n\n enum WasmEdge_ValType Params[2] = {WasmEdge_ValType_I32,\n                                    WasmEdge_ValType_I32};\n enum WasmEdge_ValType Returns[1] = {WasmEdge_ValType_I32};\n WasmEdge_FunctionTypeContext *FuncType =\n     WasmEdge_FunctionTypeCreate(Params, 2, Returns, 1);\n WasmEdge_FunctionInstanceContext *HostFunc =\n     WasmEdge_FunctionInstanceCreateBinding(\n         FuncType, FuncAddWrap, RealFunc, NULL, 0);\n WasmEdge_FunctionTypeDelete(FuncType);\n ...\n ```\n\n \\param Type the function type context to describe the host function\n signature.\n \\param WrapFunc the wrapper function pointer. The wrapper function signature\n must be as following:\n ```c\n typedef WasmEdge_Result (*WasmEdge_WrapFunc_t)(\n     void *This,\n     void *Data,\n     WasmEdge_CallingFrameContext *FrameCxt,\n     const WasmEdge_Value *Params,\n     const uint32_t ParamLen,\n     WasmEdge_Value *Returns,\n     const uint32_t ReturnLen);\n ```\n The `This` is the pointer the same as the `Binding` parameter of this\n function. The `Params` is the input parameters array with length guaranteed\n to be the same as the parameter types in the `Type`, and the `ParamLen` is\n the length of the array. The `Returns` is the output results array with\n length guaranteed to be the same as the result types in the `Type`, and the\n `ReturnLen` is the length of the array. The return value is\n `WasmEdge_Result` for the execution status.\n \\param Binding the `this` pointer of the host function target or the\n function indexing maintained by the caller which can specify the host\n function. When invoking the host function, this pointer will be the first\n argument of the wrapper function.\n \\param Data the additional object, such as the pointer to a data structure,\n to set to this host function context. The caller should guarantee the life\n cycle of the object. NULL if the additional data object is not needed.\n \\param Cost the function cost in statistics. Pass 0 if the calculation is\n not needed.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_FunctionInstanceCreateBinding(
        Type: *const WasmEdge_FunctionTypeContext,
        WrapFunc: WasmEdge_WrapFunc_t,
        Binding: *mut ::std::os::raw::c_void,
        Data: *mut ::std::os::raw::c_void,
        Cost: u64,
    ) -> *mut WasmEdge_FunctionInstanceContext;
}
extern "C" {
    #[doc = " Get the function type context of the function instance.\n\n The function type context links to the function type in the function\n instance context and owned by the context. The caller should __NOT__ call\n the `WasmEdge_FunctionTypeDelete`.\n\n \\param Cxt the WasmEdge_FunctionInstanceContext.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_FunctionInstanceGetFunctionType(
        Cxt: *const WasmEdge_FunctionInstanceContext,
    ) -> *const WasmEdge_FunctionTypeContext;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_FunctionInstanceContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_FunctionInstanceContext to destroy."]
    pub fn WasmEdge_FunctionInstanceDelete(Cxt: *mut WasmEdge_FunctionInstanceContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_TableInstanceContext.\n\n The caller owns the object and should call `WasmEdge_TableInstanceDelete` to\n destroy it if the returned object is not added into a\n `WasmEdge_ModuleInstanceContext`.\n\n \\param TabType the table type context to initialize the table instance\n context.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_TableInstanceCreate(
        TabType: *const WasmEdge_TableTypeContext,
    ) -> *mut WasmEdge_TableInstanceContext;
}
extern "C" {
    #[doc = " Get the table type context from a table instance.\n\n The table type context links to the table type in the table instance context\n and owned by the context. The caller should __NOT__ call the\n `WasmEdge_TableTypeDelete`.\n\n \\param Cxt the WasmEdge_TableInstanceContext.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_TableInstanceGetTableType(
        Cxt: *const WasmEdge_TableInstanceContext,
    ) -> *const WasmEdge_TableTypeContext;
}
extern "C" {
    #[doc = " Get the reference value in a table instance.\n\n \\param Cxt the WasmEdge_TableInstanceContext.\n \\param [out] Data the result reference value.\n \\param Offset the reference value offset (index) in the table instance.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_TableInstanceGetData(
        Cxt: *const WasmEdge_TableInstanceContext,
        Data: *mut WasmEdge_Value,
        Offset: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Set the reference value into a table instance.\n\n \\param Cxt the WasmEdge_TableInstanceContext.\n \\param Data the reference value to set into the table instance.\n \\param Offset the reference value offset (index) in the table instance.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_TableInstanceSetData(
        Cxt: *mut WasmEdge_TableInstanceContext,
        Data: WasmEdge_Value,
        Offset: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Get the size of a table instance.\n\n \\param Cxt the WasmEdge_TableInstanceContext.\n\n \\returns the size of the table instance."]
    pub fn WasmEdge_TableInstanceGetSize(Cxt: *const WasmEdge_TableInstanceContext) -> u32;
}
extern "C" {
    #[doc = " Grow a table instance with a size.\n\n \\param Cxt the WasmEdge_TableInstanceContext.\n \\param Size the count of reference values to grow in the table instance.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_TableInstanceGrow(
        Cxt: *mut WasmEdge_TableInstanceContext,
        Size: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_TableInstanceContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_TableInstanceContext to destroy."]
    pub fn WasmEdge_TableInstanceDelete(Cxt: *mut WasmEdge_TableInstanceContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_MemoryInstanceContext.\n\n The caller owns the object and should call `WasmEdge_MemoryInstanceDelete`\n to destroy it if the returned object is not added into a\n `WasmEdge_ModuleInstanceContext`.\n\n \\param MemType the memory type context to initialize the memory instance\n context.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_MemoryInstanceCreate(
        MemType: *const WasmEdge_MemoryTypeContext,
    ) -> *mut WasmEdge_MemoryInstanceContext;
}
extern "C" {
    #[doc = " Get the memory type context from a memory instance.\n\n The memory type context links to the memory type in the memory instance\n context and owned by the context. The caller should __NOT__ call the\n `WasmEdge_MemoryTypeDelete`.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_MemoryInstanceGetMemoryType(
        Cxt: *const WasmEdge_MemoryInstanceContext,
    ) -> *const WasmEdge_MemoryTypeContext;
}
extern "C" {
    #[doc = " Copy the data to the output buffer from a memory instance.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext.\n \\param [out] Data the result data buffer of copying destination.\n \\param Offset the data start offset in the memory instance.\n \\param Length the requested data length. If the `Offset + Length` is larger\n than the data size in the memory instance, this function will failed.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_MemoryInstanceGetData(
        Cxt: *const WasmEdge_MemoryInstanceContext,
        Data: *mut u8,
        Offset: u32,
        Length: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Copy the data into a memory instance from the input buffer.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext.\n \\param Data the data buffer to copy.\n \\param Offset the data start offset in the memory instance.\n \\param Length the data buffer length. If the `Offset + Length` is larger\n than the data size in the memory instance, this function will failed.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_MemoryInstanceSetData(
        Cxt: *mut WasmEdge_MemoryInstanceContext,
        Data: *const u8,
        Offset: u32,
        Length: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Get the data pointer in a memory instance.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext.\n \\param Offset the data start offset in the memory instance.\n \\param Length the requested data length. If the `Offset + Length` is larger\n than the data size in the memory instance, this function will return NULL.\n\n \\returns the pointer to data with the start offset. NULL if failed."]
    pub fn WasmEdge_MemoryInstanceGetPointer(
        Cxt: *mut WasmEdge_MemoryInstanceContext,
        Offset: u32,
        Length: u32,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Get the const data pointer in a const memory instance.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext.\n \\param Offset the data start offset in the memory instance.\n \\param Length the requested data length. If the `Offset + Length` is larger\n than the data size in the memory instance, this function will return NULL.\n\n \\returns the pointer to data with the start offset. NULL if failed."]
    pub fn WasmEdge_MemoryInstanceGetPointerConst(
        Cxt: *const WasmEdge_MemoryInstanceContext,
        Offset: u32,
        Length: u32,
    ) -> *const u8;
}
extern "C" {
    #[doc = " Get the current page size (64 KiB of each page) of a memory instance.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext.\n\n \\returns the page size of the memory instance."]
    pub fn WasmEdge_MemoryInstanceGetPageSize(Cxt: *const WasmEdge_MemoryInstanceContext) -> u32;
}
extern "C" {
    #[doc = " Grow a memory instance with a page size.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext.\n \\param Page the page count to grow in the memory instance.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_MemoryInstanceGrowPage(
        Cxt: *mut WasmEdge_MemoryInstanceContext,
        Page: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_MemoryInstanceContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext to destroy."]
    pub fn WasmEdge_MemoryInstanceDelete(Cxt: *mut WasmEdge_MemoryInstanceContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_GlobalInstanceContext.\n\n The caller owns the object and should call `WasmEdge_GlobalInstanceDelete`\n to destroy it if the returned object is not added into a\n `WasmEdge_ModuleInstanceContext`.\n\n \\param GlobType the global type context to initialize the global instance\n context.\n \\param Value the initial value with its value type of the global instance.\n This function will fail if the value type of `GlobType` and `Value` are not\n the same.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_GlobalInstanceCreate(
        GlobType: *const WasmEdge_GlobalTypeContext,
        Value: WasmEdge_Value,
    ) -> *mut WasmEdge_GlobalInstanceContext;
}
extern "C" {
    #[doc = " Get the global type context from a global instance.\n\n The global type context links to the global type in the global instance\n context and owned by the context. The caller should __NOT__ call the\n `WasmEdge_GlobalTypeDelete`.\n\n \\param Cxt the WasmEdge_GlobalInstanceContext.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_GlobalInstanceGetGlobalType(
        Cxt: *const WasmEdge_GlobalInstanceContext,
    ) -> *const WasmEdge_GlobalTypeContext;
}
extern "C" {
    #[doc = " Get the value from a global instance.\n\n \\param Cxt the WasmEdge_GlobalInstanceContext.\n\n \\returns the current value of the global instance."]
    pub fn WasmEdge_GlobalInstanceGetValue(
        Cxt: *const WasmEdge_GlobalInstanceContext,
    ) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Set the value from a global instance.\n\n This function will do nothing if the global context is set as the `Const`\n mutation or the value type not matched.\n\n \\param Cxt the WasmEdge_GlobalInstanceContext.\n \\param Value the value to set into the global context."]
    pub fn WasmEdge_GlobalInstanceSetValue(
        Cxt: *mut WasmEdge_GlobalInstanceContext,
        Value: WasmEdge_Value,
    );
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_GlobalInstanceContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_GlobalInstanceContext to destroy."]
    pub fn WasmEdge_GlobalInstanceDelete(Cxt: *mut WasmEdge_GlobalInstanceContext);
}
extern "C" {
    #[doc = " Get the executor context from the current calling frame.\n\n \\param Cxt the WasmEdge_CallingFrameContext.\n\n \\returns the executor context, NULL if the Cxt is NULL."]
    pub fn WasmEdge_CallingFrameGetExecutor(
        Cxt: *const WasmEdge_CallingFrameContext,
    ) -> *mut WasmEdge_ExecutorContext;
}
extern "C" {
    #[doc = " Get the module instance of the current calling frame.\n\n When a WASM function is executing and start to call a host function, a frame\n with the module instance which the WASM function belongs to will be pushed\n onto the stack. And therefore the calling frame context will record that\n module instance.\n So in one case that the module instance will be `NULL`: developers execute\n the function instance which is a host function and not added into a module\n instance.\n\n \\param Cxt the WasmEdge_CallingFrameContext.\n\n \\returns the module instance of the current calling frame."]
    pub fn WasmEdge_CallingFrameGetModuleInstance(
        Cxt: *const WasmEdge_CallingFrameContext,
    ) -> *const WasmEdge_ModuleInstanceContext;
}
extern "C" {
    #[doc = " Get the memory instance by index from the module instance of the current\n calling frame.\n\n By default, a WASM module only have one memory instance after instantiation.\n Therefore, developers can use:\n   `WasmEdge_CallingFrameGetMemoryInstance(Cxt, 0)`\n to get the memory instance in host function body.\n This extension is for the WASM multiple memories proposal. After enabling\n the proposal, there may be greater than 1 memory instances in a WASM module.\n So developers can use this function to access the memory instances which are\n not in 0 index.\n\n \\param Cxt the WasmEdge_CallingFrameContext.\n \\param Idx the index of memory instance in the module instance.\n\n \\returns the memory instance, NULL if not found."]
    pub fn WasmEdge_CallingFrameGetMemoryInstance(
        Cxt: *const WasmEdge_CallingFrameContext,
        Idx: u32,
    ) -> *mut WasmEdge_MemoryInstanceContext;
}
extern "C" {
    #[doc = " Wait a WasmEdge_Async execution.\n\n \\param Cxt the WasmEdge_ASync."]
    pub fn WasmEdge_AsyncWait(Cxt: *const WasmEdge_Async);
}
extern "C" {
    #[doc = " Wait a WasmEdge_Async execution with timeout.\n\n \\param Cxt the WasmEdge_ASync.\n \\param Milliseconds times to wait.\n\n \\returns Result of waiting, true for execution ended, false for timeout\n occurred."]
    pub fn WasmEdge_AsyncWaitFor(Cxt: *const WasmEdge_Async, Milliseconds: u64) -> bool;
}
extern "C" {
    #[doc = " Cancel a WasmEdge_Async execution.\n\n \\param Cxt the WasmEdge_ASync."]
    pub fn WasmEdge_AsyncCancel(Cxt: *mut WasmEdge_Async);
}
extern "C" {
    #[doc = " Wait and get the return list length of the WasmEdge_Async execution.\n\n This function will wait until the execution finished and return the return\n value list length of the executed function. This function will return 0 if\n the `Cxt` is NULL, the execution was failed, or the execution was canceled.\n Developers can call the `WasmEdge_AsyncGet` to get the execution status and\n the return values.\n\n \\param Cxt the WasmEdge_ASync.\n\n \\returns the return list length of the executed function."]
    pub fn WasmEdge_AsyncGetReturnsLength(Cxt: *const WasmEdge_Async) -> u32;
}
extern "C" {
    #[doc = " Wait and get the result of WasmEdge_Async execution.\n\n This function will wait until the execution finished and return the\n execution status and the return values.\n If the `Returns` buffer length is smaller than the arity of the function,\n the overflowed return values will be discarded.\n\n \\param Cxt the WasmEdge_ASync.\n \\param [out] Returns the WasmEdge_Value buffer to fill the return values.\n \\param ReturnLen the return buffer length.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_AsyncGet(
        Cxt: *const WasmEdge_Async,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_Async.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_ASync to destroy."]
    pub fn WasmEdge_AsyncDelete(Cxt: *mut WasmEdge_Async);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_VMContext.\n\n The caller owns the object and should call `WasmEdge_VMDelete` to destroy\n it.\n\n \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of VM.\n NULL for the default configuration.\n \\param StoreCxt the WasmEdge_StoreContext as the external WASM store of VM.\n The instantiation and execution will refer to this store context, and the\n life cycle should be ensured until the VM context is deleted. NULL for the\n default store owned by `WasmEdge_VMContext`.\n\n \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_VMCreate(
        ConfCxt: *const WasmEdge_ConfigureContext,
        StoreCxt: *mut WasmEdge_StoreContext,
    ) -> *mut WasmEdge_VMContext;
}
extern "C" {
    #[doc = " Register and instantiate WASM into the store in VM from a WASM file.\n\n Load a WASM file from the path, and register all exported instances and\n instantiate them into the store into the VM with their exported name and\n module name.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext which contains the store.\n \\param ModuleName the WasmEdge_String of module name for all exported\n instances.\n \\param Path the NULL-terminated C string of the WASM file path.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_VMRegisterModuleFromFile(
        Cxt: *mut WasmEdge_VMContext,
        ModuleName: WasmEdge_String,
        Path: *const ::std::os::raw::c_char,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Register and instantiate WASM into the store in VM from a buffer.\n\n Load a WASM module from a buffer, and register all exported instances and\n instantiate them into the store into the VM with their exported name and\n module name.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext which contains the store.\n \\param ModuleName the WasmEdge_String of module name for all exported\n instances.\n \\param Buf the buffer of WASM binary.\n \\param BufLen the length of the buffer.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_VMRegisterModuleFromBuffer(
        Cxt: *mut WasmEdge_VMContext,
        ModuleName: WasmEdge_String,
        Buf: *const u8,
        BufLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Instantiate and register an AST Module into a named module instance in VM.\n\n Load from the AST Module, and register all exported instances and\n instantiate them into the store in VM with their exported name and module\n name.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext which contains the store.\n \\param ModuleName the WasmEdge_String of module name for all exported\n instances.\n \\param ASTCxt the WasmEdge AST Module context generated by loader or\n compiler.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_VMRegisterModuleFromASTModule(
        Cxt: *mut WasmEdge_VMContext,
        ModuleName: WasmEdge_String,
        ASTCxt: *const WasmEdge_ASTModuleContext,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Register a module instance into the store in VM with exporting its module\n name.\n\n After calling this function, the existing module instance will be registered\n into the store context in this VM, and the other modules can import the\n exported instances for linking when instantiation. Developers SHOULD\n guarantee the life cycle of this existing module instance, or the error will\n occur when in execution after the module instance being destroyed if it has\n been imported by other modules. That is, developers should call the\n `WasmEdge_ModuleInstanceDelete` if this existing module instance will not be\n used anymore or after the deletion of this VM. When the module instance is\n deleted, it will be unregistered to the store context in this VM\n automatically.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext which contains the store.\n \\param ImportCxt the WasmEdge_ModuleInstanceContext to register.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_VMRegisterModuleFromImport(
        Cxt: *mut WasmEdge_VMContext,
        ImportCxt: *const WasmEdge_ModuleInstanceContext,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Instantiate the WASM module from a WASM file and invoke a function by name.\n\n This is the function to invoke a WASM function rapidly.\n Load and instantiate the WASM module from the file path, and then invoke a\n function by name and parameters. If the `Returns` buffer length is smaller\n than the arity of the function, the overflowed return values will be\n discarded.\n After calling this function, a new module instance is instantiated, and the\n old one will be destroyed.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param Path the NULL-terminated C string of the WASM file path.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n \\param [out] Returns the WasmEdge_Value buffer to fill the return values.\n \\param ReturnLen the return buffer length.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_VMRunWasmFromFile(
        Cxt: *mut WasmEdge_VMContext,
        Path: *const ::std::os::raw::c_char,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Instantiate the WASM module from a buffer and invoke a function by name.\n\n This is the function to invoke a WASM function rapidly.\n Load and instantiate the WASM module from a buffer, and then invoke a\n function by name and parameters. If the `Returns` buffer length is smaller\n than the arity of the function, the overflowed return values will be\n discarded.\n After calling this function, a new module instance is instantiated, and the\n old one will be destroyed.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param Buf the buffer of WASM binary.\n \\param BufLen the length of the buffer.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n \\param [out] Returns the WasmEdge_Value buffer to fill the return values.\n \\param ReturnLen the return buffer length.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_VMRunWasmFromBuffer(
        Cxt: *mut WasmEdge_VMContext,
        Buf: *const u8,
        BufLen: u32,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Instantiate the WASM module from a WasmEdge AST Module and invoke a function\n by name.\n\n This is the function to invoke a WASM function rapidly.\n Load and instantiate the WASM module from the WasmEdge AST Module, and then\n invoke the function by name and parameters. If the `Returns` buffer length\n is smaller than the arity of the function, the overflowed return values will\n be discarded.\n After calling this function, a new module instance is instantiated, and the\n old one will be destroyed.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param ASTCxt the WasmEdge AST Module context generated by loader or\n compiler.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n \\param [out] Returns the WasmEdge_Value buffer to fill the return values.\n \\param ReturnLen the return buffer length.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_VMRunWasmFromASTModule(
        Cxt: *mut WasmEdge_VMContext,
        ASTCxt: *const WasmEdge_ASTModuleContext,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Instantiate the WASM module from a WASM file and asynchronous invoke a\n function by name.\n\n This is the function to invoke a WASM function rapidly.\n Load and instantiate the WASM module from the file path, and then invoke a\n function by name and parameters. If the `Returns` buffer length is smaller\n than the arity of the function, the overflowed return values will be\n discarded.\n After calling this function, a new module instance is instantiated, and the\n old one will be destroyed.\n\n The caller owns the object and should call `WasmEdge_AsyncDelete` to destroy\n it.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param Path the NULL-terminated C string of the WASM file path.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n\n \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call\n `WasmEdge_AsyncDelete` to destroy this object."]
    pub fn WasmEdge_VMAsyncRunWasmFromFile(
        Cxt: *mut WasmEdge_VMContext,
        Path: *const ::std::os::raw::c_char,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
    ) -> *mut WasmEdge_Async;
}
extern "C" {
    #[doc = " Instantiate the WASM module from a buffer and asynchronous invoke a function\n by name.\n\n This is the function to invoke a WASM function rapidly.\n Load and instantiate the WASM module from a buffer, and then invoke a\n function by name and parameters. If the `Returns` buffer length is smaller\n than the arity of the function, the overflowed return values will be\n discarded.\n After calling this function, a new module instance is instantiated, and the\n old one will be destroyed.\n\n The caller owns the object and should call `WasmEdge_AsyncDelete` to destroy\n it.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param Buf the buffer of WASM binary.\n \\param BufLen the length of the buffer.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n\n \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call\n `WasmEdge_AsyncDelete` to destroy this object."]
    pub fn WasmEdge_VMAsyncRunWasmFromBuffer(
        Cxt: *mut WasmEdge_VMContext,
        Buf: *const u8,
        BufLen: u32,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
    ) -> *mut WasmEdge_Async;
}
extern "C" {
    #[doc = " Instantiate the WASM module from a WasmEdge AST Module and asynchronous\n invoke a function by name.\n\n This is the function to invoke a WASM function rapidly.\n Load and instantiate the WASM module from the WasmEdge AST Module, and then\n invoke the function by name and parameters. If the `Returns` buffer length\n is smaller than the arity of the function, the overflowed return values will\n be discarded.\n After calling this function, a new module instance is instantiated, and the\n old one will be destroyed.\n\n The caller owns the object and should call `WasmEdge_AsyncDelete` to destroy\n it.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param ASTCxt the WasmEdge AST Module context generated by loader or\n compiler.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n\n \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call\n `WasmEdge_AsyncDelete` to destroy this object."]
    pub fn WasmEdge_VMAsyncRunWasmFromASTModule(
        Cxt: *mut WasmEdge_VMContext,
        ASTCxt: *const WasmEdge_ASTModuleContext,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
    ) -> *mut WasmEdge_Async;
}
extern "C" {
    #[doc = " Load the WASM module from a WASM file.\n\n This is the first step to invoke a WASM function step by step.\n Load and parse the WASM module from the file path. You can then call\n `WasmEdge_VMValidate` for the next step.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param Path the NULL-terminated C string of the WASM file path.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_VMLoadWasmFromFile(
        Cxt: *mut WasmEdge_VMContext,
        Path: *const ::std::os::raw::c_char,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Load the WASM module from a buffer.\n\n This is the first step to invoke a WASM function step by step.\n Load and parse the WASM module from a buffer. You can then call\n `WasmEdge_VMValidate` for the next step.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param Buf the buffer of WASM binary.\n \\param BufLen the length of the buffer.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_VMLoadWasmFromBuffer(
        Cxt: *mut WasmEdge_VMContext,
        Buf: *const u8,
        BufLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Load the WASM module from loaded WasmEdge AST Module.\n\n This is the first step to invoke a WASM function step by step.\n Copy the loaded WasmEdge AST Module context into VM. The VM context has no\n dependency on the input AST Module context. You can then call\n `WasmEdge_VMValidate` for the next step.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param ASTCxt the WasmEdge AST Module context generated by loader or\n compiler.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_VMLoadWasmFromASTModule(
        Cxt: *mut WasmEdge_VMContext,
        ASTCxt: *const WasmEdge_ASTModuleContext,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Validate the WASM module loaded into the VM context.\n\n This is the second step to invoke a WASM function step by step.\n After loading a WASM module into VM context, You can call this function to\n validate it. And you can then call `WasmEdge_VMInstantiate` for the next\n step. Note that only validated WASM modules can be instantiated in the VM\n context.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_VMValidate(Cxt: *mut WasmEdge_VMContext) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Instantiate the validated WASM module in the VM context.\n\n This is the third step to invoke a WASM function step by step.\n After validating a WASM module in the VM context, You can call this function\n to instantiate it. And you can then call `WasmEdge_VMExecute` for invoking\n the exported function in this WASM module.\n After calling this function, a new module instance is instantiated, and the\n old one will be destroyed.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_VMInstantiate(Cxt: *mut WasmEdge_VMContext) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Invoke a WASM function by name.\n\n This is the final step to invoke a WASM function step by step.\n After instantiating a WASM module in the VM context, the WASM module is\n registered into the store in the VM context as an anonymous module. Then you\n can repeatedly call this function to invoke the exported WASM functions by\n their names until the VM context is reset or a new WASM module is registered\n or loaded. For calling the functions in registered WASM modules with module\n names, please use `WasmEdge_VMExecuteRegistered` instead. If the `Returns`\n buffer length is smaller than the arity of the function, the overflowed\n return values will be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n \\param [out] Returns the WasmEdge_Value buffer to fill the return values.\n \\param ReturnLen the return buffer length.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_VMExecute(
        Cxt: *mut WasmEdge_VMContext,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Invoke a WASM function by its module name and function name.\n\n After registering a WASM module in the VM context, you can repeatedly call\n this function to invoke exported WASM functions by their module names and\n function names until the VM context is reset. If the `Returns` buffer length\n is smaller than the arity of the function, the overflowed return values will\n be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param ModuleName the module name WasmEdge_String.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n \\param [out] Returns the WasmEdge_Value buffer to fill the return values.\n \\param ReturnLen the return buffer length.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message."]
    pub fn WasmEdge_VMExecuteRegistered(
        Cxt: *mut WasmEdge_VMContext,
        ModuleName: WasmEdge_String,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Asynchronous invoke a WASM function by name.\n\n This is the final step to invoke a WASM function step by step.\n After instantiating a WASM module in the VM context, the WASM module is\n registered into the store in the VM context as an anonymous module. Then you\n can repeatedly call this function to invoke the exported WASM functions by\n their names until the VM context is reset or a new WASM module is registered\n or loaded. For calling the functions in registered WASM modules with module\n names, please use `WasmEdge_VMAsyncExecuteRegistered` instead.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n\n \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call\n `WasmEdge_AsyncDelete` to destroy this object."]
    pub fn WasmEdge_VMAsyncExecute(
        Cxt: *mut WasmEdge_VMContext,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
    ) -> *mut WasmEdge_Async;
}
extern "C" {
    #[doc = " Asynchronous invoke a WASM function by its module name and function name.\n\n After registering a WASM module in the VM context, you can repeatedly call\n this function to invoke exported WASM functions by their module names and\n function names until the VM context is reset.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param ModuleName the module name WasmEdge_String.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n\n \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call\n `WasmEdge_AsyncDelete` to destroy this object."]
    pub fn WasmEdge_VMAsyncExecuteRegistered(
        Cxt: *mut WasmEdge_VMContext,
        ModuleName: WasmEdge_String,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
    ) -> *mut WasmEdge_Async;
}
extern "C" {
    #[doc = " Get the function type by function name.\n\n After instantiating a WASM module in the VM context, the WASM module is\n registered into the store in the VM context as an anonymous module. Then you\n can call this function to get the function type by the exported function\n name until the VM context is reset or a new WASM module is registered or\n loaded. For getting the function type of functions in registered WASM\n modules with module names, please use `WasmEdge_VMGetFunctionTypeRegistered`\n instead.\n The returned function type context are linked to the context owned by the VM\n context, and the caller should __NOT__ call the\n `WasmEdge_FunctionTypeDelete` to destroy it.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param FuncName the function name WasmEdge_String.\n\n \\returns the function type. NULL if the function not found."]
    pub fn WasmEdge_VMGetFunctionType(
        Cxt: *const WasmEdge_VMContext,
        FuncName: WasmEdge_String,
    ) -> *const WasmEdge_FunctionTypeContext;
}
extern "C" {
    #[doc = " Get the function type by function name.\n\n After registering a WASM module in the VM context, you can call this\n function to get the function type by the functions' exported module names\n and function names until the VM context is reset.\n The returned function type context are linked to the context owned by the VM\n context, and the caller should __NOT__ call the\n `WasmEdge_FunctionTypeDelete` to destroy it.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param ModuleName the module name WasmEdge_String.\n \\param FuncName the function name WasmEdge_String.\n\n \\returns the function type. NULL if the function not found."]
    pub fn WasmEdge_VMGetFunctionTypeRegistered(
        Cxt: *const WasmEdge_VMContext,
        ModuleName: WasmEdge_String,
        FuncName: WasmEdge_String,
    ) -> *const WasmEdge_FunctionTypeContext;
}
extern "C" {
    #[doc = " Reset of WasmEdge_VMContext.\n\n After calling this function, the statistics, loaded module, the instantiated\n instances, and the registered instances except the WASI and plug-ins will\n all be cleared.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext to reset."]
    pub fn WasmEdge_VMCleanup(Cxt: *mut WasmEdge_VMContext);
}
extern "C" {
    #[doc = " Get the length of exported function list.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns length of exported function list."]
    pub fn WasmEdge_VMGetFunctionListLength(Cxt: *const WasmEdge_VMContext) -> u32;
}
extern "C" {
    #[doc = " Get the exported function list.\n\n The returned function names filled into the `Names` array link to the\n exported names of functions owned by the vm context, and the caller should\n __NOT__ call the `WasmEdge_StringDelete` to destroy them.\n The function type contexts filled into the `FuncTypes` array of the\n corresponding function names link to the context owned by the VM context.\n The caller should __NOT__ call the `WasmEdge_FunctionTypeDelete` to destroy\n them.\n If the `Names` and `FuncTypes` buffer lengths are smaller than the result of\n the exported function list size, the overflowed return values will be\n discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param [out] Names the output names WasmEdge_String buffer of exported\n functions. Can be NULL if names are not needed.\n \\param [out] FuncTypes the function type contexts buffer. Can be NULL if\n function types are not needed.\n \\param Len the buffer length.\n\n \\returns actual exported function list size."]
    pub fn WasmEdge_VMGetFunctionList(
        Cxt: *const WasmEdge_VMContext,
        Names: *mut WasmEdge_String,
        FuncTypes: *mut *const WasmEdge_FunctionTypeContext,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the module instance corresponding to the WasmEdge_HostRegistration\n settings.\n\n When creating the VM context with a configuration, the built-in host module\n will be registered according to the `WasmEdge_HostRegistration` settings\n added into the `WasmEdge_ConfigureContext`. You can call this function to\n get the `WasmEdge_ModuleInstanceContext` corresponding to the settings. The\n module instance context links to the context owned by the VM context. The\n caller should __NOT__ call the `WasmEdge_ModuleInstanceDelete`.\n\n ```c\n WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();\n WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);\n WasmEdge_VMContext *VM = WasmEdge_VMCreate(Conf, NULL);\n WasmEdge_ModuleInstanceContext *WasiMod =\n     WasmEdge_VMGetImportModuleContext(VM, WasmEdge_HostRegistration_Wasi);\n ```\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param Reg the host registration value to get the import module.\n\n \\returns pointer to the module instance context. NULL if not found."]
    pub fn WasmEdge_VMGetImportModuleContext(
        Cxt: *const WasmEdge_VMContext,
        Reg: WasmEdge_HostRegistration,
    ) -> *mut WasmEdge_ModuleInstanceContext;
}
extern "C" {
    #[doc = " Get the current instantiated module in VM.\n\n After instantiating a module instance into the VM, developers can call this\n API to get the module instance to retrieve the exported instances. The\n module instance context links to the context owned by the VM context. The\n caller should __NOT__ call the `WasmEdge_ModuleInstanceDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns pointer to the module instance context. NULL if not found."]
    pub fn WasmEdge_VMGetActiveModule(
        Cxt: *const WasmEdge_VMContext,
    ) -> *const WasmEdge_ModuleInstanceContext;
}
extern "C" {
    #[doc = " Get the registered module in VM by the module name.\n\n After registering a WASM module into the VM context, developers can call\n this function to get the module instance by the module name. The returned\n module instance context links to the context owned by the VM context, and\n the caller should __NOT__ call the `WasmEdge_ModuleInstanceDelete` to\n destroy it.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param ModuleName the module name WasmEdge_String.\n\n \\returns pointer to the module instance context. NULL if not found."]
    pub fn WasmEdge_VMGetRegisteredModule(
        Cxt: *const WasmEdge_VMContext,
        ModuleName: WasmEdge_String,
    ) -> *const WasmEdge_ModuleInstanceContext;
}
extern "C" {
    #[doc = " Get the length of registered module list in the WasmEdge_VMContext.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns length of registered module list."]
    pub fn WasmEdge_VMListRegisteredModuleLength(Cxt: *const WasmEdge_VMContext) -> u32;
}
extern "C" {
    #[doc = " List the registered module names in the WasmEdge_VMContext.\n\n This function will list all registered module names.\n The returned module names filled into the `Names` array are linked to the\n registered module names in the VM context, and the caller should __NOT__\n call the `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the registered\n named module list size, the overflowed return values will be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param [out] Names the output names WasmEdge_String buffer of the registered\n modules.\n \\param Len the buffer length.\n\n \\returns actual registered module list size."]
    pub fn WasmEdge_VMListRegisteredModule(
        Cxt: *const WasmEdge_VMContext,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the store context used in the WasmEdge_VMContext.\n\n The returned store context links to the store in the VM context and owned by\n the VM context. This function will return NULL if error occurs. The caller\n should __NOT__ call the `WasmEdge_StoreDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns pointer to the store context."]
    pub fn WasmEdge_VMGetStoreContext(Cxt: *mut WasmEdge_VMContext) -> *mut WasmEdge_StoreContext;
}
extern "C" {
    #[doc = " Get the loader context used in the WasmEdge_VMContext.\n\n The returned loader context links to the loader in the VM context and owned\n by the VM context. This function will return NULL if error occurs. The\n caller should __NOT__ call the `WasmEdge_LoaderDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns pointer to the loader context."]
    pub fn WasmEdge_VMGetLoaderContext(Cxt: *mut WasmEdge_VMContext)
        -> *mut WasmEdge_LoaderContext;
}
extern "C" {
    #[doc = " Get the validator context used in the WasmEdge_VMContext.\n\n The returned validator context links to the validator in the VM context and\n owned by the VM context. This function will return NULL if error occurs. The\n caller should __NOT__ call the `WasmEdge_ValidatorDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns pointer to the validator context."]
    pub fn WasmEdge_VMGetValidatorContext(
        Cxt: *mut WasmEdge_VMContext,
    ) -> *mut WasmEdge_ValidatorContext;
}
extern "C" {
    #[doc = " Get the executor context used in the WasmEdge_VMContext.\n\n The returned executor context links to the executor in the VM context and\n owned by the VM context. This function will return NULL if error occurs. The\n caller should __NOT__ call the `WasmEdge_ExecutorDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns pointer to the executor context."]
    pub fn WasmEdge_VMGetExecutorContext(
        Cxt: *mut WasmEdge_VMContext,
    ) -> *mut WasmEdge_ExecutorContext;
}
extern "C" {
    #[doc = " Get the statistics context used in the WasmEdge_VMContext.\n\n The statistics context links to the statistics in the VM context and owned\n by the VM context. The caller should __NOT__ call the\n `WasmEdge_StatisticsDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns pointer to the statistics context."]
    pub fn WasmEdge_VMGetStatisticsContext(
        Cxt: *mut WasmEdge_VMContext,
    ) -> *mut WasmEdge_StatisticsContext;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_VMContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_VMContext to destroy."]
    pub fn WasmEdge_VMDelete(Cxt: *mut WasmEdge_VMContext);
}
extern "C" {
    #[doc = " Entrypoint for the compiler tool.\n\n This function provides an entrypoint to the WasmEdge AOT compiler tool with\n the command line arguments.\n\n \\param Argc the argument count.\n \\param Argv the argument vector.\n\n \\returns the execution status."]
    pub fn WasmEdge_Driver_Compiler(
        Argc: ::std::os::raw::c_int,
        Argv: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Entrypoint for the runtime tool.\n\n This function provides an entrypoint to the WasmEdge runtime tool with the\n command line arguments.\n\n \\param Argc the argument count.\n \\param Argv the argument vector.\n\n \\returns the execution status."]
    pub fn WasmEdge_Driver_Tool(
        Argc: ::std::os::raw::c_int,
        Argv: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Entrypoint for the unified tool.\n\n This function provides an entrypoint to the WasmEdge unified tool with the\n command line arguments.\n\n \\param Argc the argument count.\n \\param Argv the argument vector.\n\n \\returns the execution status."]
    pub fn WasmEdge_Driver_UniTool(
        Argc: ::std::os::raw::c_int,
        Argv: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Load plugins with the default search paths.\n\n The default paths are:\n   1. The environment variable \"WASMEDGE_PLUGIN_PATH\".\n   2. The \"../plugin/\" directory related to the WasmEdge installation path.\n   3. The \"wasmedge/\" directory under the library path if the WasmEdge is\n      installed under the \"/usr\"."]
    pub fn WasmEdge_PluginLoadWithDefaultPaths();
}
extern "C" {
    #[doc = " Load the plugin with the given file or directory.\n\n For the given file path, this function will load the plug-in.\n For the given directory path, this function will load the plug-ins under the\n directory recursively.\n\n \\param Path the path to plug-in file or directory."]
    pub fn WasmEdge_PluginLoadFromPath(Path: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get the length of loaded plug-in list.\n\n \\returns length of loaded plug-in list."]
    pub fn WasmEdge_PluginListPluginsLength() -> u32;
}
extern "C" {
    #[doc = " List the loaded plug-ins with their names.\n\n The returned plug-in names filled into the `Names` array are owned by the\n internal WasmEdge plug-in storage, and the caller should __NOT__ call the\n `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the loaded\n plug-in list size, the overflowed return values will be discarded.\n\n \\param [out] Names the output WasmEdge_String buffer of the function names.\n \\param Len the buffer length.\n\n \\returns actual loaded plug-in list size."]
    pub fn WasmEdge_PluginListPlugins(Names: *mut WasmEdge_String, Len: u32) -> u32;
}
extern "C" {
    #[doc = " Find the loaded plug-in context by name.\n\n After loading the plug-ins from default paths or the given path, developers\n can use this API to retrieve the plug-in context by name. Then developers\n can create the module instance from the plug-in contexts.\n\n \\param Name the plug-in name WasmEdge_String.\n\n \\returns pointer to the plug-in context. NULL if the plug-in not found."]
    pub fn WasmEdge_PluginFind(Name: WasmEdge_String) -> *const WasmEdge_PluginContext;
}
extern "C" {
    #[doc = " Get the plug-in name of the plug-in context.\n\n The returned string object is linked to the plug-in name of the plug-in\n context, and the caller should __NOT__ call the `WasmEdge_StringDelete`.\n\n \\param Cxt the WasmEdge_PluginContext.\n\n \\returns string object. Length will be 0 and Buf will be NULL if failed."]
    pub fn WasmEdge_PluginGetPluginName(Cxt: *const WasmEdge_PluginContext) -> WasmEdge_String;
}
extern "C" {
    #[doc = " Get the length of module list in the plug-in context.\n\n There may be several modules in a plug-in. Developers can use this function\n to get the length of the module list in a plug-in.\n\n \\param Cxt the WasmEdge_PluginContext to get the length of the module list.\n\n \\returns length of module list."]
    pub fn WasmEdge_PluginListModuleLength(Cxt: *const WasmEdge_PluginContext) -> u32;
}
extern "C" {
    #[doc = " List the modules in the plug-in context with their names.\n\n The returned module names filled into the `Names` array are owned by the\n internal WasmEdge plug-in storage, and the caller should __NOT__ call the\n `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the loaded\n plug-in list size, the overflowed return values will be discarded.\n\n \\param Cxt the WasmEdge_PluginContext to list the modules.\n \\param [out] Names the output WasmEdge_String buffer of the function names.\n \\param Len the buffer length.\n\n \\returns actual module list size of the plug-in."]
    pub fn WasmEdge_PluginListModule(
        Cxt: *const WasmEdge_PluginContext,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Create the module instance in the plug-in by the module name.\n\n By giving the module name, developers can retrieve the module in the plug-in\n and create the module instance.\n The caller owns the object and should call `WasmEdge_ModuleInstanceDelete`\n to destroy it.\n\n \\param Cxt the WasmEdge_PluginContext to retrieve and create module.\n \\param ModuleName the module name to retrieve.\n\n \\returns pointer to the module instance context, NULL if the module name not\n found in the plug-in or the plug-in is not valid."]
    pub fn WasmEdge_PluginCreateModule(
        Cxt: *const WasmEdge_PluginContext,
        ModuleName: WasmEdge_String,
    ) -> *mut WasmEdge_ModuleInstanceContext;
}
extern "C" {
    #[doc = " Implement by plugins for returning the plugin descriptor.\n\n \\returns the plugin descriptor."]
    pub fn WasmEdge_Plugin_GetDescriptor() -> *const WasmEdge_PluginDescriptor;
}
